二零一六年关键词————“好的习惯，好的思考，好的表达，好的交流”

“在那些年月里，我们为了推翻卓越的前辈们，废寝忘食地不知付出了多大的努力。现在的
风尚的确与当时不大相同了。眼下，日本围棋界的条件相当优越。比如学棋的场所、学棋的
对手几乎遍地皆是。然而只有这些，似乎还不足以激发棋手们学习的冲动，因为能让他们感
动的东西太少了。或许正是因为年轻棋手们拥有的太多，结果反倒成了他们的不幸。”

* 题记
“好的习惯”想表达的意思和前两年相比并无改变，只是今年我想确切地形成一两个助益一生
的习惯，比如说规律地睡眠和锻炼，保持解题(编程，数学，游戏，etc)的胃口。今年我加
入了“好的思考”，因为我发现很多时候先有了“好的思考”，才有“好的表达”。“好的思考”常
常需要是深入的，不应该浅尝辄止，只看表象。坚持去做“好的思考”，就可能使自己分析判
断的能力越来越强。这样，才是真正通往“自己的正解”的路。

补记：到二月份，我意识到还应该有“好的交流”。因为一个人有时尽其所能所能想到做到的
事情是很有限的，而找到好的圈子，和好的/强的人交往和沟通能极大的拓展一个人的视野，
打破原有的局限。既然意识到了这点，我会试着去寻找好的伙伴好的圈子（比如在老朋友中，
在学校，在公司，在网络，通过朋友的朋友，等等），并在其中产生思想的交流和碰撞。

** 火花卷首语

塞林格写过一部名作叫《麦田里的守望者》，里面的主人公是一个被学校开除的中学生，他
貌似玩世不恭，厌倦现存的平庸的一切，但他并非没有理想。他想象悬崖边有一块大麦田，
一大群孩子在麦田里玩，而他的理想就是站在麦田边作一个守望者，专门捕捉朝悬崖边上乱
跑的孩子，防止他们掉下悬崖。

我很喜欢“守望者”这个名称，它使我想起守林人。守林人的心境总是非常宁静的，他长年与
树木、松鼠、啄木鸟这样一些最单纯的生命为伴，他自己的生命也变得单纯了。他的全部生
活就是守护森林，瞭望云天，这守望的生涯使他心明眼亮，不染尘嚣。“守望者”的名称还使
我想起守灯塔人。在奔流的江河中，守灯塔人日夜守护灯塔，瞭望潮汛，保护着船只的安全
航行。当然，与都市人相比，守林人的生活未免冷清。与弄潮儿相比，守灯塔人的工作未免
平凡。可是，你决不能说他们是人类中可有可无的一员。如果没有这些守望者的默默守望，
森林消失，地球化为沙漠，都市人到哪里去寻欢作乐，灯塔熄灭，航道变为墓穴，弄潮儿如
何还能大出风头？

人做事情，或出于利益，或出于性情。凡出于性情做的事情，大都仅仅是为了满足心灵需求，
如写作、艺术欣赏、交友等等。我们做这个主页也是如此，愉快是最基本的标准。如果什么
时候我们在这里找不到愉快，就必须怀疑是否有利益的强制在其中起着作用，使性情生活蜕
变成了功利行为。火花是这样一个地方，它不想在踌躇满志的游戏精英网站中挤自己的一块
地盘，而是很安静的，与世无争的，但也因此在普遍的热闹和竞争中有了存在的价值。我们
只想开辟一块园地，让火炎玩家们找到回家的感觉。

如果一个人有自己的心灵追求，又在世界上闯荡了一番，有了相当的人生阅历，那么，他就
会逐渐意识到自己在这个世界上的位置。世界无限广阔，诱惑永无止境，然而，属于每一个
人的现实可能性终究是有限的。你不妨对一切可能性保持着开放的心态，因为那是人生魅力
的源泉，但同时你也要早一些在世界之海上抛下自己的锚，找到最合适自己的领域。一个人
不论伟大还是平凡，只要他顺应自己的天性，找到了自己真正喜欢做的事，并且一心把自己
喜欢做的事做到尽善尽美，他在这个世界上就有了牢不可破的家园。于是，他不但会有足够
的勇气去承受外界的压力，并且会有足够的清醒来面对形形色色的机会的诱惑。我们当然没
有理由怀疑，这样的一个人必能获得生活的充实和心灵的宁静。
* Jan
** 1.2 结束Boston之行
短短11天，没想到发生了那么多事。无论在 *做事* 和 *感情* 上都有很多体会和收获，同时也让我明确了今年的一些目标和打算。我会好好吸收这些收获和体会，变得更好。
** 1.3
*** programming tips
"最开始需要多花时间敲代码，这段时间免不了会敲很多重复的代码，但是无所谓，因为这段
时间自己就是一个白痴。然而，当代码可以畅通无阻的表达自己思想的时候，就需要多看书
了，让你的思想得到更大的提升，从而可以写出更多更有深度与更有意义的代码。"
*** 《倚天屠龙记》中赵敏是怎么把张无忌追到手的？
赵敏能追到张无忌的秘诀：“我偏要勉强”

常言道：男追女，隔座山；女追男，隔层纱，但是今天讲的“女追男”思路对广大光棍男依然
是适用的，因为“女追男、隔层纱”那得看对手是谁。敏敏的对手不是一个，至少是仨！而且
除了珠儿，其余都是重量级人物！

 小四是金庸作品中女仆系列的代表人物、万千宅男的YY对象、人气比肩双儿的小昭！

 小三更厉害了——周芷若，听名字就是美女，实际更是美女，貌若天仙，曾经秒杀张无忌、
宋青书。同时，她还智慧过人、出身名门，手握武林秘籍，总之，基本上是完美的。放到任
何一本武侠小说里做女一号都绝对是绰绰有余的，加上本来就和无忌哥哥熟识多年，从哪个
角度看，都是当仁不让的绝对胜利者！

可是，她败了！她不是输给了赵敏，打败她的是爱情!

全书写到一半赵敏才出场，金先生，您还能再NB一点么？但是敏敏只用了不到全书八分之一
的篇幅就气场全开，征服了几乎所有读者，金先生，你还真能再NB了。

敏敏特穆尔，汉语名字为赵敏，身份为蒙古郡主，司职国家安全局，主要职能为剿灭江湖反
动人士，比如明教恐怖组织头目张无忌。此女智慧过人，设计将六大派一网打尽，张无忌的
各位师叔伯全部落入她手，殷六侠差点丧命，无忌最尊敬的三丰太师傅也差点中招；性格强
硬，多次明算、暗算张无忌，屡次弄得张无忌灰头土脸，还差点自杀以谢天下……说到这里，
我都不相信她能拖下根正苗红的周芷若成功上位。

 她就两招：疯狂爱和水银泻地般犀利无比的表白。前者为体，后者为用，双剑合璧，天下
莫当。

疯狂爱，大家都有体会。她放弃郡主身份，放弃大好前程，甚至放弃家庭，义无反顾地去追
一个一直站在自己对立面的土匪头子。在张无忌和周芷若结婚典礼上，周围全部是赵敏死敌，
她单刀赴会抢亲时，发生了如下对话：【范遥眉头一皱，说道：“郡主，世上不如意事十居
八九，既已如此，也是勉强不来了。赵敏道：“我偏要勉强。”】然后我就义无反顾、毅然决
然地爱上了这个妖女。

 疯狂爱到这就不说了，一来大家可以很容易地从书中体会到，二来这个也不具备可操作性。
如果你碰到了你的真命天子，那就由不得你不去疯狂；如果你仅仅是感觉合适或者还算般配，
你怎么都疯狂不起来。

 下面重点学习敏敏的表白。教科书般的表白，分寸的拿捏，情景的设计，心理的捕捉，都
华丽得让我不禁感叹：金老爷子当年肯定也是高手啊！

第一次，赵敏和张无忌在大都的一间小酒店里喝酒。

 【张无忌拿起酒杯，火锅的炭火光下见杯边留着淡淡的胭脂唇印，鼻中闻到一阵清幽的香
气，也不知这香气是从杯上的唇印而来，还是从她身上而来，不禁心中一荡，便把酒喝了。
赵敏道：“再喝两杯。我知道你对我终是不放心，每一杯我都先尝一口。】

深夜，小店，烛光，幽香……这气氛营造得！然后打着反毒品的名义和张无忌同饮一杯酒。要
知道，共享饮料的行为一般只发生在关系十分亲密的人之间。此时两人是对立身份，但敏敏
反而借势把关系悄然拉近，然后展开一系列人生观、价值观、善恶观的探讨。看见没，不管
是追美女还是帅哥，最初都得来点有层次的，谈人生、谈理想是最好、最快、最安全的开始
阶段话题。人生理想谈拢以后，敏敏又出招了—— 【赵敏道：“要是我明天死了，你心里怎样
想？你心中一定说：谢天谢地，我这个刁钻凶恶的大对头死了，从此可免了我不少麻烦。”】
摸出张无忌已然对自己有点小动心，立刻以退为进！逼宫！目标达成以后，为了使自己不显
得过于强势，立刻又问：【张公子，你说是我美呢，还是周姑娘美？】这叫色诱……洗刷自己
强势形象，第一轮较量敏敏完胜无忌，成功把之前的对立形象转化成了无忌心中的美好印象。

 然后两人在灵蛇岛“度蜜月”时，赵敏咬了张无忌的手，又在他手上抹去腐消肌膏，这一段，
堪称金书调情第一桥段。其后周芷若强势反击，陷害赵敏。赵敏再见无忌之时，已经是杀害
殷离、偷走刀剑的嫌疑犯了。 【张无忌脸上如罩严霜，喝道：“你要盗那倚天剑和屠龙刀，
我不怪你！你将我抛在荒岛之上，我也不怪你！可是殷姑娘已然身受重伤，你何以还要再下
毒手！似你这等狠毒的女子，当真天下少见。”说到此处，悲愤难抑，跨上一步，左右开弓，
便是四记耳光。赵敏在他掌力笼罩之下，如何闪避得了？啪啪啪啪四声响过，两边脸颊登时
红肿。】


如果是你，遭人陷害，九死一生，好不容易见到爱人还不信任自己一顿耳光，你会有什么感
受？愤怒？委屈？心冷？不甘？仇恨？那是你们，我们敏敏完全不一样。 敏敏此时完全掌
握了无忌的心理，看她此时表现：【赵敏追了出来，叫道：“张无忌，你往哪里去？”张无忌
道：“跟你有什么相干？”赵敏道：“我有话要问谢大侠和周姑娘，请你带我去见他二人。”张
无忌道：“我义父下手不容情，你这不是去送死？”赵敏冷笑道：“你义父心狠手辣，可不似
你这等糊涂。再说，谢大侠杀了我，你是报了表妹之仇，岂不是正好偿了你的心愿？”张无
忌道：“我糊涂什么？我不愿你去见我义父。”赵敏微笑道：“张无忌，你这糊涂小子，你心
中实在舍不得我，不肯让我去给谢大侠杀了，是也不是？”】

 后来，张无忌发现殷离是被周芷若杀的，反应却很平淡，连重话都没说两句，这是为什么？

其实，张无忌的愤怒是出于内心中对赵敏的爱，如果赵敏杀了殷离，自己就不能和她继续在
一起了，因此恨其不争才打她耳光。敏敏对无忌的心思洞若观火，强大的洞察力给她带来无
穷自信。她知道哪怕全世界都与她为敌，无忌也会出来保护她的，于是长剑出鞘，逼得无忌
手足无措。

第二回合，敏敏再次在极端不利的条件下完胜！

 其后两人躲入鼓中，外面斗得如火如荼。【赵敏将嘴凑到张无忌耳边，轻轻说道：“你这该
死的小淫贼！”这一句话似嗔似怒，如诉如慕，说来娇媚无限，张无忌只听得心中一荡，霎
时间意乱情迷，极是烦恼：“倘若她并非如此奸诈险毒，害死我的表妹，我定当一生和她长
相厮守，什么什么也不顾得了。”】

 一句耳边轻语，威力竟如此之大！身外则是如火如荼的争斗，两人处于极其危险的处境当
中，可是，纵然如此，也没有“我要对你说我有多么爱你”来得重要！这样的情状，谁能不动
情？谁能不动心？ 再往后，周芷若使尽各种功夫，略微稳住局势，陪着无忌到了大都。无
忌来到两人初次相遇的酒店，发现赵敏居然也在，一切如故。瞬间被击倒了……

反观周芷若，此时只能一哭二闹三上吊了，失败基本无可挽回。再后来的抢亲什么的已经不
重要了，因为无忌已心有所属，他需要的，只是一个冠冕堂皇的理由，比如救义父。一旦理
由找到，没有了道德的羁绊，他就立刻义无反顾地投入敏敏的怀抱中。

 谈三点启示。

 首先，光爱还不够，要大声说出来。你不说我怎么知道你要呢？赵敏除了爱得比芷若更炽
烈之外，她更加勇于且善于表达自己的爱。而且当碰到困难和挫折的时候，有人会患得患失，
畏首畏尾，而赵敏选择的是更加积极地一往无前，最后她赢得爱情。

其次，光有勇气不够，还要有足够的技巧。

技巧的第一层是要懂得营造氛围，创造机会。未必要有烛光、有鲜花，君不见，赵敏同学对
路边小店、海岛、游船、破庙，无不应用得得心应手。关键在于创造接触机会，让双方要么
觉得十分放松，要么觉得十分刺激。无论是大排档、大马路，还是过山车、看鬼片，其实都
是好环境，就看你怎么用。再比如小店的二次邂逅，多好的环境。你或许没有这样的缘分，
但是完全可以侦察好地形，自己制造一场这样的邂逅。

 技巧的第二层则在于敏锐的观察。每次无忌心里的想法在赵敏那里都是纤毫毕现的，然后
她再从容选择以退为进、步步紧逼、单刀直入等各种战术。不过，心理观察是很难的，不是
每个人都能像敏敏这样做到心理大师级的观察，但是，请冷静地用脑子去听对方说话。她说，
你去死，多半不是让你去死，而是高兴又不好意思表露；她说，你很好，那你就可以真的去
死了。

 最后，很多时候，两个人已经势成水火，全世界都对你不抱希望了。不要顾及面子，不要
担心嘲笑，不要把爱埋在心底，记住郡主说的“我偏要勉强”。这就叫真挚。
** 1.5
*** full court press
*** how to stuff a sleeping bag?
*** 给2015(让眉)
完成2015这四下敲击时，实实确确已是2016年了。开年当头的三天愁霾依旧，而我也被十余日的北京咳牵出了肺热，闭窗隐几，只沉沉病着。

检点平生这种抛付心力的活儿，似乎在病枕上是挺合宜的，几日来微信网间见了不少朋友应景的总结和计划，沉思往事时就难免也起了动念。

以日期作为岁月之刻度，很能见古人性冷之自虐。若无一个避无可避的端点，谁又能找到一个那么合理的由头去伤感所谓大江流日夜呢。



我很少用“老”这个词来形容时光流逝，因为我讨厌强加败相给任何事物——这个任何里也包括我自己。一年过去，奔三之路还有不短的行程，而我也依旧不惮于矫情和卖萌，但站在年尾年头回顾，似乎不得不伤感地承认我或许确实和去年的此时有些不同了。

或许是因为事业的日益企稳——也或许只是长大。当初那个目无下尘的姑娘已渐渐肯于入世。

第一次有此警醒是今年夏天。当时出差去了趟云南，项目不靠谱，券商便自然亲和。忙完公务闲聊时，一个热衷于乐嘉所谓性格色彩学的小哥建议大家测一测各自的性格，我不愿拂人兴致，便如他言逐题答了。

意料之中的绿色人格，小哥听到答案却愣了一下，我问起原因，他笑着说：“看李老师出项目时谈笑风生，气象不凡，跟宋美龄相去仿佛，我以为该是个女强人呢。”

一语如当头棒喝，倒把我自己唬了一跳。网络诗坛里我被惯加的称呼是“第一含羞草”，盖因每及英雄小宴时，我总是温驯讷言的；而在德国时，也很惯了被人喊着“神仙姐姐”来喻所谓不接地气——然而看来我举止的适应能力还要强于心灵的惯性，职场忽忽两年余，虽然骨子里仍厌于应酬，性子上看，倒已很能捭阖自如了。

可是，虽然“女强人”的气场令我向来羡慕，小哥这句话却依然令我不快且慌张了许久。

又后来我换了工作。

面试是处极古雅幽静的所在，分花拂柳革履翩翩，行止间就也难免有些矜持张致。待得后来跟同事们熟悉了，秘书跟我说他当时对我的印象是个“很有自信的能力型管理者”——及至这时我才无奈接受自己原来已经是一头如此成熟的大尾巴狼的事实。

此后渐渐地，我也会开始翻翻金融类各种大部头，也惯于闲暇时点进各种财经类公众号去看看各家靠谱或不靠谱的言论，更时常要跟天台、高树、杨虚白、佛爷等诗词圈的朋友一回回天南海北地从宏观大势浑侃到股债纷纭——而转过头来想想这种伪事业型人物姿态，却曾经是少年时那个矜持戒备的我多么不屑的。

我小时候对未来的想象颇得神雕侠式中二中年范儿。时常YY着自己戴着人皮面具在金融的江湖里飘然去来，片叶不沾身——而揭下假面后，却只见十六年来苍白清俊依旧。然而想来是因为我的江湖太过炽热，乃而方才两年光景，面具的纹路便已作用于肌理了。

许是往来见惯了香风鬓影的丽人与衣冠楚楚的才俊，对自己就也或多或少有了些不清高却矜贵的期冀吧——至今行止爱好虽犹不能俗，却也为着怕给人家说句文人多落魄，就再绝不肯一味清高地压着自己走到“非诗不可”的境地去。

好么？不好么？回头想来，虽然有点小不甘，也还须要接受了。只因比较起一个不再清高的社会人，我更反感的还是百无一用却犹自愤世嫉俗抢文学史话语权的酸丁，嗯，尚有好恶，纵然是变化着，那也很好了。



一年间，诗人的聚会虽不常有，却也零星不断。别聚匆匆，京中诸子也往往有些“相过不寂寥”的心念。点检起来，和这群人相识堪堪也已七年，坐在筵中猛忆重头，却发现自己确然已是嗔笑自若，虽非侃侃之辈，却也绝不似当年的腼腆稚子了。八胡有次感叹说：初与众人识时大家还是聊诗的，复几年，说情场爱恨，再几年，言立业成家，而今却已是子女成行，多有不能语矣——而我作为北平圈儿里最小的一位，就也免不了要时时被他们催问起几时生子，无论最终做何答复，少时桀骜的心气却总是沉定下去了。

我倒觉得这沉定让我舒服。看着每个诗人都在所谓的市井烟火中周旋抵挡，对诗，我就也少了几分少年人固有急功近利的进取心。许是过起了步履匆匆的日子，才更加向往随机游走式的浪费与碰撞吧——这一年来，或读或写，我的自由度似乎都要比从前大得多了。

不惮于在所有自己半吊子的领域里思考和碰壁，对诗而言或许也算是一种不务正业的致敬？阅读之间不再追求于增长功力，下笔之时也不再心系名家，于是我今年写东西的时候倒是在哲学、美术和西诗里好好拧巴了一圈。蘸出来洋洋一抖脸，无论行为了什么艺术，这身段倒也近如一只高傲的沙皮狗了。

我素来不法古人，也不在意门派家数。只因我之所以愿意写诗而不仅仅是读诗，正在于自己喜欢去捕捉一些在斟酌语句时终将落于构想区间外的、衍生出来的意外灵机。这灵机虽大多时候是游离而不成形的，但也偶尔极能令我惊艳。细微的游跃仿佛历史中的一只只扇动翅膀的蝴蝶，或许将决定整首诗的走向——因为让我抓着，所以它终而存在。这种感觉的美好，没有经过思考和创作的人们恐怕是很难体会的。

于是这一年来我写诗的时候更常毫不吝惜地抛弃原始的成句去追寻一霎狂慧，然而这尝试也是有时成功，有时失败。今年我的诗写得比往年更少了，自己读起来，脑子也要拧几个弯几似要沥出水来。从文字上讲，这种写法大大影响着所谓初心的真诚，怕是入了小障的。然而这障既能让我目眩和欣喜，那就也不妨耽几年吧。

法古的诗人往往甘心顺着趋势线把文字运转下去，而不敢闻见这些可爱的方差。而读诗时，我们看到的更仅仅成了不再具有时间性的成品。拜泥塑不如心中有，这一年来我浑写浑读，隐隐觉得要写得有成就感和快乐，只怕还是应该放下一些责任心和敬畏感的。



最后，今年放下敬畏感之于我，还见于一些心结的解开。

这一年我见到了睽违多年的朋友，也在这次见面里荡没了网间交集的最后一层遗憾。倘和曾经同道的朋友经年重见时依然能相语如故，恍如渚涯岁月不曾遥隔，那么就中曾有的误解种种，便也就都成了过去式里一道释然的笑纹。

我十分很感激这种仪式感，正如我感激岁月之所以为岁月，肯于如此温柔地分离开所谓的“曾经”和“倘如”。

是的。All above。谢谢2015。
** 1.6
*** first try spothero
** 1.7 things to abandon this year
*** several things to abandon in order to save more time this year
**** weiqi video watching
**** Chinese news website surfing
**** fruitless chatting, dining outside
*** check if a ubuntu package is installed
apt-cache policy *package name*
*** fun sentences
继上海一男子造谣自己因造谣而被拘留15日而被拘留15日；美术馆反法西斯胜利70周年画展
因庆祝反法西斯胜利70周年活动而暂停；俄罗斯一票否决了乌克兰提出的取消俄罗斯一票否
决权的安理会提案之后......中国股市为预防恶化而紧急停止的熔断机制为预防恶化而紧急
停止。
*** successfully find a proxy to run netease musicbox on Ubuntu
also learned from Luo Dan that *pptp+shadowsocks* is another approach to solve the problem
*** TODO I know roughly what is *API*. But what does the code actually look like, can you find good real world analogy?
*** China's broken stockmarket(from economist)
Update, January 7th, 3.50pm London: China's stock exchanges announced on
Thursday evening that they would suspend use of the circuit-breakers. The
securities regulator said they were not the main cause of the market's fall but
had not achieved their aim and had instead caused a 'magnet effect', as
described in the article below.

BIG swings in the Chinese stockmarket are par for the course. But even by its
wild standards, the alacrity of its latest crash was stunning. Just 13 minutes
into trading on Thursday, the CSI 300 index of blue-chip stocks fell 5%,
triggering the first circuit-breaker: a 15-minute pause for traders to
supposedly regain their cool. When the action resumed, it lasted all of one
minute before the second and final circuit-breaker was hit: the CSI 300 fell 7%,
which necessitated a closure of the market for the rest of day. Trading, in
other words, lasted all of 14 minutes before being halted.

The obvious conclusion to draw from the market sell-off is that China’s economy
is in big trouble. Why else would investors be in such a rush to dump their
shares? Growth is certainly slowing, but the problem with this view is that the
Chinese stockmarket has only ever had a tenuous relationship with reality. It is
often derided as a casino. Wu Jinglian, a veteran economist, has quipped that
this is unfair to casinos. They have strict rules and gamblers cannot see each
other’s cards. In China's stockmarket, the rules rarely apply to big investors,
who treat price manipulation as a basic trading strategy.

But while the swings of the Chinese market defy explanations most of the time,
there is actually extensive research to help explain the dynamics of the latest
crash. For the culprit, look no further than the circuit-breakers that
regulators introduced at the start of this week. Only four days into operation,
they have already been triggered in much the same manner twice: with the 5%
threshold hit first and then full closure at the 7% level soon after. The theory
of circuit-breakers is that they are supposed to help calm an over-excited
market. In China’s case, it appears that they have done just the opposite:
encouraging traders to lock in sell orders to make sure they are the first to
escape the market before the bottom falls out.

For analysts who have studied circuit-breakers, this should not be surprising.
They generally fall into two camps: those who think they help to reduce
volatility and those who worry they exacerbate it by leading to an acceleration
of trading before halts occur. But even the former acknowledge that
circuit-breakers pose the risks described by the latter. The general view is
thus that that they should only be applied in extreme cases.

As Arthur Levitt, then chairman of America's Securities and Exchange Commission
(SEC), explained in 1998:

Circuit-breakers were meant, from their inception, to be triggered only in truly
extraordinary circumstances—ie, a severe market decline when the prices have
dropped so dramatically that liquidity and credit dry up, and when prices
threaten to cascade in a panic-driven spiral. As long as the markets are closed
or have the potential to close early, there is uncertainty. Uncertainty for
individual investors leads to confusion. In China, big swings between the open
and close of the stockmarket used to be the norm, much to the chagrin of
reporters who were expected to divine something intelligible from the movements.
Peter Thal Larsen of Reuters Breakingviews put it best in a tweet: “Iron rule of
Chinese stockmarkets: any observation based on intraday movements will be
obsolete by the close of trading.”

The introduction of circuit-breakers has changed this logic. They have
highlighted a problem known as the “magnet effect”. The Hong Kong Securities and
Futures Commission defined this in a 2001 article as the possibility that
circuit-breakers might “accelerate price movements towards the preannounced
limits as market participants alter their strategies and trade in anticipation
of a market halt”.

Based on the four days in which China’s breakers have been in operation, the
first magnetic pull seems to kick in at around 4% down. Traders rush to sell
before they are locked out. After trading starts again at 5% down, the magnetic
draw to 7% is almost irresistible; no one wants to be left holding the hot
potato.

In its design of the circuit-breakers, China has violated one of the basic
principles of those countries that also apply them: the gaps between breaker
levels should be sufficiently wide to avoid having an overwhelming magnet
effect. The SEC halts trading at the 7%, 13% and 20% thresholds for the S&P 500
index. And bear in mind that American markets are far more mature, making even
7% changes a rarity. In China, the 5% threshold is something that was crossed
with regularity before the circuit-breakers were introduced, with the market
often giving up its gains or paring its losses over the course of the frenetic
trading day. Now, though, the circuit-breaker makes those lurches permanent,
until the next trading day begins.

None of this means that the Chinese stockmarket should be performing well. Share
prices, especially for small-cap stocks, are still extremely frothy. But the
madness of 14-minute-long trading days was utterly avoidable. The latest update
is that the securities regulator has called an unscheduled meeting to discuss
the circuit-breakers, according to Bloomberg. If only they had bothered to
discuss them properly before implementation.
*** arrive in Chicago, join with Wenbin
** 1.8 Reunion with Dongming at Purdue!
** 1.9 revisit Chicago in rain & snow
 Willis tower(didn't climb), Millenium Park/Cloud Gate, Art Institute, 名轩（粤菜）
*** *until you*, song
** 1.10 visit Jinwei at Notre Dame in snow, revisit Chicago in better weather, reunion with Xuecheng, Jun & Yitong
** 1.16
*** 练刀工
作者：灰子
链接：https://www.zhihu.com/question/19980549/answer/21237905
来源：知乎

1.刀具和案板做中餐，基本上3把刀就够了。砍刀是多大块的骨头，火腿啊、排骨啊之类的。
剁刀一般用来剁鸡、鸭、兔子之类骨头小的禽类，还有就是剁肉馅、剁姜蒜的时候用。切刀
用的最多，素菜和没有骨头的肉一般都用切刀。案板要大一点的好，因为大案板更稳，在厨
房里一般不用案板，用墩子，二十多厘米高，就像是一树墩子，多形象。如果觉得自家的案
板不稳，总是晃动，可以在案板下面垫一块帕子，就稳多了。2.磨刀磨刀石有两种，一种是
砂石，一种是油石，砂石粗糙，油石更光滑细腻。刀太钝了，就先用砂石来粗磨，刀刃的角
度磨好了，再用油石来磨地平滑。刀与磨刀石夹角为30度左右，刀刃太薄了很脆，太厚了不
够锋利。我之前在餐厅切菜，每人有自己的专用刀，我们几乎每天都要磨刀，最多3天要磨
一次，不然自己的菜刀太钝了，要被同事们鄙视。但在家里不必这么频繁，毕竟我们当时一
天要切七八个小时的菜。磨得特别棒的刀，拿一个稍微软一点的土豆，削去皮放在案板上，
把刀立上去，手握着刀把，几乎不需要用力，刀靠着自身的重力就能切下去一半。（这也是
因为餐厅里的刀本身就比家用刀更大更重）3.刀法刀法有很多种，入门的刀法，会几种就够
了。直切，垂直下刀，干净利落，绝大多数蔬菜都都是直切法。推切，比较柔软的食物，比
如绝大多数肉类，直着下刀，肉的形状要走样，边向前推边下刀。推拉切，特别硬的东西，
比如冻牛肉、大头菜之类的，还有就是特别易碎的食物，比如面包、馒头，要用推拉切，方
法类似于锯。花刀，餐厅里做的鱿鱼卷、松鼠鱼、肝腰合炒之类的，原料要上花刀，一般来
说，每一刀要切到原料的3/4处，但一定不能切断，属于难度比较大的刀法。剁，肉馅啊、
姜蒜末啊。我们在厨房里剁姜蒜，有时候一次十几斤，两把刀左右手一起剁，剁熟练了能剁
出马奔跑时马蹄发出的“哒——哒哒——哒——哒哒”的声音，节奏特别动感过瘾。砍，主要对付大
骨头，刀要举过头顶，猛地砍下去，砍下去的速度要快，还需要花些力气。三刀都能砍到同
一个位置，你就出师了。其实，也不必我讲刀法的理论，实践中大家自然会找到最适合的刀
法。4.切菜的姿势两脚自然分开，上半身微微前倾，但不要弯腰，案板的高度大概在腰部，
身体至少离案板一拳。右手握刀，大拇指自然弯曲，左手放在食物上，指头弯曲，用中指第
一个关节顶在最前面。刀垂直下刀，抬起刀的高度永远不要超过左手中指的高度。如果你能
一直保持这样的姿势，从理论上来说，你就永远也不会切到手了。5.终于可以开始切菜了以
切土豆丝为例吧。左手按稳土豆（把土豆比较平的一面放在案板上），右手垂直下刀，切下
了的土豆片，上下要一样厚薄。注意要使用腕力下刀，不要用胳膊的力气。切一刀后，左手
中指第一个关节往左退2毫米（别真拿尺子去量哈，凭感觉），再重新下刀，眼睛看着刀的
右边。关节连着退3-4次后，把整个左手向左退一小截。土豆切掉1/3左右，把切面平放在案
板上，这样土豆就特别稳了，继续切。土豆都切成片以后平铺码好，按照同样的方法切成丝。
（写着写着，就怀念起当年一帮同事一切比赛切土豆丝的时候，谁都不服谁，我当时的技术
还是不错的，平均2分钟可以切出一盘比火柴棍差不了太多的土豆丝，现在手生了，不行了。）
再说说切肉。肉难切的原因在于比较柔软，容易跑偏。切肉的时候，左手要按得稳一点，下
刀要边向前推便下刀，利索果断一点，切下去后刀往右边偏一下，切好的那片肉就掉下去了。
冻得不那么硬的肉，要容易切得多。一块肉切了90%，最后一小坨，是最难切的了，这里要
引入一个名词，叫片，可以把肉平方过来，刀也与案板平行，这样推拉着切，叫片，技术要
难一些。6.怎样把刀工练好熟能生巧，刀工是一项技能，智商再高，技巧再好，不练出手感
来，刀工是好不了的。认真切，切菜是一件很无聊的事情，很容易跑神，边切菜，边聊个天
想个心事啥的，当然，这样除了容易切到手以外，也没啥坏处。但如果想切得好，同样要认
真才行，切菜的时候把注意力集中在两只手上，很快就能找到手感。
*** order
作者：谢熊猫君
链接：https://www.zhihu.com/question/22074052/answer/20208275
来源：知乎

中餐炒菜的大概炒菜顺序：1.烧热油和锅2.大葱、生姜、蒜、各种椒，爆香3.放主料炒脱生
4.料酒、酱油、醋，去腥上色调味5.家常菜可以加高汤或者水焖熟6.盐、糖、味精、鸡精等
调味7.勾芡8.撒葱花以上步骤和料不是每道菜都必须要，看你炒什么菜调整用料、步骤、顺
序。

请不要追问油多热算热、盐怎么放、各种调料放多少这类问题。参考《做饭要快，无他，唯手熟尔。》
http://zhuanlan.zhihu.com/xiepanda/19608807
** 1.17
*** 给丫的信
本来有些话是想当面对丫说的，不过一来电话几次想约你打不通，二来觉得发普通信息也不
够庄重，所以选择了信的方式。

我是一个不喜欢矫情、直来直去的人，所以这话也大大咧咧的说————在波士顿相处的那几天
里，丫让我心动了。我喜欢丫。这份喜欢和你姐他们无关，虽然如果没有他们的暗示和鼓励，
我未必会真的会想到表白。因为心动，所以去看过你之前的微信还有校内能看到的状态，想
多了解丫。看过后，我觉得，丫是个很有性格的姑娘，虽然在杨叔叔那不是那么明显：）


“自古表白多白表，从来姻缘少原因”。川哥毕竟也二十八岁了，知道这些道理。从你的回应，
我知道你对我是没什么感觉心有回避的。可也有句话，叫做“说了后悔总比不说后悔来得好”。
既然是自己真实产生了的心意，那么去做忠实地自我表达就不是件坏事。

我知道我大你五岁，可咱这都什么时代了，五岁无非也就是半辈人，而且重要的是我觉得我
的心怀依然少年。我知道你决定了回国，可那天车上我也和你说过，文化上我对美国没什么
留恋的。除了父母，我几个最好的朋友都在国内，我看的清留美和回国的得失。如果是和喜
欢的姑娘一起探索未来，我愿意。我知道我学理你学文，可我觉得这其实可以互补，况且我
这个人骨子里其实感性，在理解别人这点上悟性不差。当然，如果我是长相上没过你心里的
阀值，那就该一票否决了。作为外貌协会会员，我完全理解~

我相信，这世界上真正美好的东西，都应该是简单明快的，对便对了，不对便是不对。人与
人间的理解有天然的局限，可若不去做真实明快的表达，是永远也无法突破那层局限，而实
现心与心间相对理解的。你对你自己的心有最好的判断，我这封信本质上是为了我自己的忠
实表达，你读的时候可不需要烦恼啥，若是能会心一笑那是最好了！

总之，我希望你我之间的表达是单纯明快的。如果你对我没有感觉，那就直说，我这人明白
“一个巴掌拍不响”，看得清这缘分该怎么惜,从此以后，做你合格的朋友、大哥就够了。如
果你觉得我们有希望,但还需一些时间方能开始，那就我追你。

好了，写到这我想我试图表达的也大致清楚了。于我来说，循心而往，随缘而去，纵是难成
美眷也不负少年心怀。虽然未必能打动你，可你对我可能有的误会也该消解了。和丫这样的
好姑娘认识，是我有缘。无论如何，做你合格的一位朋友和大哥，是我可以完成的承诺~

最后，祝丫在LA玩的开心。等你回来，欢迎你来我的地盘，我一定带你好吃好喝好玩：）

                                                                                                              川哥
                                                                                                  二零一六年一月十七日夜于新泽西

** 1.20

*** 1st 回信
川哥：

谢谢你写这封邮件给我，抱歉我看到晚了。

我一直都处于一个并不想谈恋爱的状态，这么说也不是在敷衍你，因为我从来都没有谈过正
式的男朋友。你从我姐姐她们的态度就可以看出来，她们都很希望我可以和一个很好的人开
始一段感情，大概是因为她们怕我拖着拖着就剩下了把。但我现在依然没有这方面的想法，
现在的状态我就很舒服了。

我其实是一个非常慢热的人，要和别人成为朋友前需要很长的时间。这回在波士顿认识你们
当然是很愉快的，但是对我而言其实是一个很不自然的状态。就像你说的一样，我在我舅舅
家并不是真正的性格，这样的相遇真的是很遗憾。我想，如果我们是慢慢熟悉起来，在了解
对方的喜恶之后再这样长时间的相处大概会更好一些吧。就像“丫”这个称呼，我其实一直不
喜欢这个名字，也就是家人会这样叫我，我的朋友同学没有一个人是知道的。每次家人以外
的人发现这个称呼都让我觉得很难堪。我也应该给你说声对不起，在你访问了我人人网之后
把能屏蔽的都屏蔽了实在是不礼貌的做法。我不是对你有什么意见，我只是一直都不希望别
人了解到我还没有准备好让他们了解的地方。人人网的账号我一直都是想删除的，只不过忘
了注册邮箱的密码我删不掉。我以为你发现以后应该会讨厌我，不理我了，没想到你还是对
我这么耐心，谢谢你啦。

我从来没觉得你大我五岁或者文科理科会是个问题。只是和你的热情相比，我实在是一个太
过冷漠的人了。我习惯和大部分人相处都保持着一段距离，整个家里的平辈，我真正关心的
就只有这一个姐姐。我也讨厌维持异地的感情，无论是友情还是亲情。哪怕是和旦旦姐姐，
我们不在一个城市的时候也基本上是不联系的状态。所以我如果先你一步回国，我实在是不
敢保证什么。退一步说，我们两个根本不算是真正的了解对方，你要放弃在这边这么多年的
积累贸然和我回国，我良心上都会过不去。

你骨子里是一个很感性的人，但我其实很理性。我没有觉得你不好，我就是觉得完全不可行。
其实要说谈段恋爱也不是不行，毕竟我家人都有点着急了。可这样做的话就太自私了，毕竟
我觉得不可行那我就不会投入，而你在现在的这个年龄，应该是会想谈认真严肃的感情了把。
我和我姐姐她们一直都觉得你是很体贴很真诚的人，我也不希望到了最后结下一个仇人。

你看，真正的我和你想的大概完全不一样吧。要是我们是很自然的相识相知，这些麻烦尴尬
可能就都不会有了。我其实也不习惯对着不熟悉的人做这样的自我剖白，把这么讨厌的自己
直接展示给别人看。毕竟如果只是做朋友，很多事情根本就不需要了解到的。不过要是你觉
得哪怕我这么讨厌都还可以做朋友的话，以后就叫我一同或者直接说“你”就可以了。真的很
谢谢你。

*** art of the command line
some examples:

1. bash下，用tab补全，ctrl-r 搜索命令历史
2. ctrl-w删除当前命令的一个单词，ctrl-u
   删除到行首，ctrl-k删除行尾，ctrl-a移动到行首，ctrl-e移动到行尾
3. ctrl-x
   ctrl-e 可以调用自己定义的编辑器来编辑当前命令行，当你要写一串超长的命令的时候
   就知道有多好用了
4. cd -回到上次的目录
5. 输入命令不想立即执行，但是又想保存到
   history中供搜索，怎么办？ ctrl-a跳到行首，加一个#，回车，搞定
6. pgrep搜索进
   程
7. nohup让进程忽略HUP信号，disown让后台启动的进程忽略HUP
8. 自定义命令别名，
   alias ll='ls -latr'
9. 用tmux或者screen来让你的进程不会因为ssh连接终端而被干掉

*** 2nd letter
一同（这么称呼现在有点别扭，我慢慢改）：

首先，我想说，一个人选择单身可能有很多原因：觉得一个人状态不错，没有合适的人，或
者不在合适的时间，等等。但不管是哪种，其他任何人都没有权利去强迫她/他开始。就是
我的老同学里都还有几位非常独立的女性，到现在都还享受着单身的状态（问过她们基本说
目前的目标是多赚钱= =），我特别欣赏。而你才二十三呢，完全没有必要因为家庭和周围
的压力去勉强开始一段恋情。至于我个人，虽然家里在催了，不过也就是在老妈面前说好好
好哄哄她，骨子里我不会急，觉得急了更没用，要找一定还是要找自己真的喜欢的，不能随
便就让他们给介绍了。找不到的话，一个人也有一个人的过法。

总之，在我看来，恋爱/结婚与否，何时开始，和谁开始，这些归根结底应该是一个人的独
立选择。虽然因为历史、文化、地域的限制不总是这样，但一个人发自内心地愿意，主动地
做出的选择，在大部分时候都要比被迫去选择的情况结果要好的多。

你说“这样的相遇真的是很遗憾。我想，如果我们是慢慢熟悉起来，在了解对方的喜恶之后
再这样长时间的相处大概会更好一些吧”，前半句在我看来并不是这样。我想，我们这样的
相遇是奇妙的。其实这个圣诞我本来是想回绝杨叔叔的，而我也确实原定二十三号开车去普
度。可不曾想到我那边的朋友临时和我说他要一月七号才从国内回来，我只好把行程改到那
天。然后二十号左右杨叔叔又给我打了几个电话，挨不过他的热情，最后一次我问他有没有
同龄人（当时想不然我一个小辈过去要是面对的都是他这样的长辈咋办），他说有，然后把
你联系方式告诉我看我能不能和你一起过来。所以才有了之后的相遇，在我看来还真有些奇
妙。当然也不是相遇那天就产生了追你的想法，那天只是觉得你是个可爱的小妹子（帮女生
拎箱子啥的是我向来的作风＝＝），真正有了这个想法是在你们送我礼物的那天晚上（当然
后来我也猜到了估计多半是你姐的主意）。

人和人的相遇很难预先设定一种方式，更别说是最好的那种了。我们既然这样相遇，那就是
缘分。不管命运如何流变，我会去把握我所能把握的，我想，到回首的时候，我们一定已经
成为了相知相惜的朋友。所以啊，哪有什么相遇的遗憾，我们的相知才刚刚开始呢。

你说你”太过冷漠“，首先我并不觉得，其次能消融冷漠的不也就只有热情吗？难道要以冷漠
对冷漠？不管是恋人的相处还是朋友相处，出现了问题，总有一个人要主动先走出一步才能
解决问题。至于”慢热“，可解者唯有时间和相伴。

你还提到了恋爱的可行性。我理解你觉得不可行的最主要原因一是还不真正的了解对方，二
是地点——你决定了回国，而我目前在美国好好的，两人很难在一个地方开始。我是这么想的：

我本来就想和你相知，所以去真正的了解对方本就是要做的。所以这个原因并非不可行的绝
对理由，我们边接触边了解对方，如果到了某个点我们有了默契，这个自然就不是问题了。
至于地点，这个有可能成为不可行的绝对理由，因为两个人最后若不能长时间在一起，谈什
么恋爱嘛！所以在我的理解，可行与否关键在于地点。不知你是否同意。

其实我有回国的想法很久了，自从两三年前我想清楚毕业后不做学术去业界之后，毕业后长
期留美对我的意义就不大了，因为文化上我真的对美国没啥留恋的，也就只有做学术让我觉
得非在美国不可。在遇到你之前我的想法就是毕业后如果这边有好的offer那就工作一两年
回去，不会拖到三五年；如果没有好的offer那就直接回国，理想的城市是珠三角那三个以
及上海（北京的雾霾让我没那么想去），珠三角是因为离家近同学朋友多，上海是因为如果
去那边做金融的话有不少好的connection能用上。当然我也想到了唯一的变数——未来可能的
那位姑娘，如果她是想留美的，那我想我也会决定留美；当然如果她想回国，那自然就按之
前回国的想法走。我不知道你回国后最想去哪，现在你也不必告诉我，因为我们还不熟：）
我和你说我的想法是想告诉你，如果我们在一起然后我回国了，也并没有为你特别放弃什么
牺牲什么，你完全没有需要心里过不去的地方。

说到这我想可以理一理了。你觉得现在的状态就很舒服，我其实也觉得我自己现在一个人的
状态不错（虽然能和喜欢的姑娘开始是更让人开心的）。目前至少我们可以在做朋友的过程
中去把可行性中的第一个问题解决掉。最后能不能两个都解决，使你觉得可行，那我就尽人
事而安天命吧。

既然试图去解决，那我自然就要提议咯。我不知道你现在想何时回国，我就假设在四五月吧。
那这样的话在你回国前大概还有三个月，三个月中我觉得你应该抓紧时间再去多看看美帝的
大好河山。我现在上班是part time，所以每两周出去走走都是有时间的。在美东这边自然
风光的话尼亚加拉大瀑布，仙那度(DC附近）、大烟山（田纳西州）国家公园都很不错，大
瀑布之前听你是想去的，而实际上这三处我都没有去过。我想在三个月中，我推荐你可以考
虑二月或者三月去尼亚加拉大瀑布，四月初樱花节的时候去DC看看樱花然后顺道去仙那度。
至于大烟山，五六月份的时候那儿有共鸣萤火虫的festival（而且从我们新泽西这去那的路
上可以开美国最漂亮的国家景观公路——蓝岭高速），可如果你回国的话我不知道你来不来得
及了＝＝　你可以约上你的一个同学或者朋友（如果住店正好你们share），然后我们三或
四个人（我也可以再叫上一个我的朋友和我share房间）一起road trip这几个地方。至于小
一点的地方，我之前也和你提了普林斯顿值得一看，这个地儿等你从LA回来后咱随便找一周
周四到周末的时间就能带你当天游遍。

远一点美西的话我去过的地方不少（我主要是和基友刷国家公园去的），如果你有想去但还
没去的也可以告诉我，我刚说了我现在part time，每两周都有一周的时间可以自己支配，
只要合理的计划，去西部也是没问题的。

平时的话如果周末你有空我也会找时间约你吃饭或者去看看其他的（比如百老汇看剧）。

恩，能想到的暂时就这么多。相信我现在的想法通过这信都能传达到了。

*** 2nd 回信
不好意思川哥，可能我昨天没有说清楚。我现在真的一点都不想谈恋爱，想交朋友也是想交
只会成为朋友的那种。还有我二月底就会回国，所以时间上可能真的来不及了。不好意思

*** last response
明白啦。等你LA回来还是告诉我，说好带你去普林的~~
** 1.21

“Rebounding isn't about the size of your body, it's about the size of your heart。”

*** body strength training
**** 引体向上:pull-up
very efficient way to improve strength!
**** rope skipping

*** Plan to prepare code interview

**** read *The Algorithm Design Manual*

**** read *Cracking the code interview*

**** TODO Princeton 2016 spring Algorithm Course

*** reconcile with Leila

** 1.23 Ex Machina

*** python code in movie *Ex Machina*

#BlueBook code decryption
import sys
def sieve(n):
    x = [1] * n
    x[1] = 0
    for i in range(2,n/2):
            j = 2 * i
            while j < n:
                    x[j]=0
                    j = j+i
    return x

def prime(n,x):
    i = 1
    j = 1
    while j <= n:
            if x[i] == 1:
                    j = j + 1
            i = i + 1
    return i - 1
x=sieve(10000)
code = [1206,301,384,5]
key =[1,1,2,2,]

sys.stdout.write("".join(chr(i) for i in [73,83,66,78,32,61,32]))
for i in range (0,4):
    sys.stdout.write(str(prime(code[i],x)-key[i]))

print

** 1.24 编程入门指南

*** 编程入门指南 v1.4 by 萧井陌
[[http://zhuanlan.zhihu.com/xiao-jing-mo/19959253][编程入门指南 v1.4]]

阅读此文最基本的收获即是————编程能力的提高是三位一体密不可分的：计算机硬件系统原理，算法和数据结构以及编程语言。文中开出了不少很好的书目和资源，我会尽量选择性地拿来精读或略读。

** 1.25

*** 超市结账请留心打折商品
今天在Hmart买笋，看到原价5.99/lb而现在特价3.99/lb所以买了两个，check out后回家看
receipt发现实际还是按5.99收的。以后对这种特价或者打折的东西在最后结账时一定要仔
细确认一遍。我之前在Hmart也遇到过这样的事，看来Hmart可以放入黑名单了,除非在其他
中国超市买不到的或者没有更新鲜，以后尽量不去那~~

*** Mountain Blanc in Alps
Know about it from today's google frontpage recommendation

*** got response from Yitong
** 1.26 The Witness

*** *the witness* game by Jonathan Blow

**** some players' remark

***** 1
Here’s a Hint, *Think outside of the box*. Not only think but walk around the box,
Think what the box is? Think how did the box get here? What does the box think
about me? Do you love the box? Does the box love you? Then walk away from the
box because you have no idea what you’re doing. - Luke Rising 2016

***** 2
This game is not going to be for everyone. If you're looking for a game that has
action, violence, and an engaging plot that will keep you on the edge of your
seat, look elsewhere. If you're impatient, and if you don't want your brain to
hurt, this isn't the game for you. With that being said, in the amount of time
I've invested in The Witness so far, it's already one of my favorite puzzle
games of all time. The game takes the basic concept of maze puzzles, and
introduces new mechanics to them to make you think. It then takes those new
mechanics, and gives them a little twist, to make you think even more. And then
once you think you've mastered that mechanic, it mixes it with another mechanic
that you've previously learned, or even a brand new one. This game is hard, and
it doesn't make any attempt to hold your hand. This game is going to make you
want to smash your head onto your desk, but in a good way, because you want to
conquer this latest puzzle so badly.

The game has an incredible atmosphere, with gorgeous visuals and ambient sounds
immersing you into this island world. There aren't any graphics settings, which
is a huge bummer, but hopefully that is something that could be patched into the
game. The vibrant colors of the island really pop off the screen, and the
different locations throughout the game are really neat. You can also listen to
some audio diaries located throughout the island, which have different quotes
from all sorts of different people. This would be a great game to have a podcast
on in the background. Not that the sounds are bad, they do a good enough job to
keep you immersed in the game while you're playing, but it might be nice to have
something else to listen to as well. The controls work great, on both a
controller and a keyboard and mouse. Pick whichever one you're more comfortable
with. I know a lot of people have been complaining about the $40 price tag, but
from what I've played so far, it seems absolutely worth it. There are a ton of
puzzles in here, and it's going to take you awhile to beat the game.

tl;dr I you want something different than a complex puzzle game that keeps you
on your toes with a great atmosphere, you're going to want to look elsewhere.
But if you've been craving a game like The Talos Principle or Portal, you should
absolutely pick this up. This game is worth the price tag, and it's going to be
a long time before you forget your time in The Witness.

*** HTML basics
<!DOCTYPE html>
<a hef=""> </a>
<ul>
<ol>
<img src="" width="" alt=""/>
<div id= class=> </div>
<h1> </h1>
<span class="red"> </span>

**** to specify the related CSS file
<link rel="stylesheet" type="text/css" href="../style.css" />
*** CSS basics

*** Does that *interest* you?

*** How to deblur an image?

前面的回答都是关于抓包，如何截取还没有经过模糊的图。我打算讲一个更通用的，即便服
务端给了模糊的图，照样能还原。不要以为CSI里的照片还原技术只是个特效。目前所用的
模糊，基本都是卷积，而且几乎都是用gaussian kernel卷积。而根据卷积定理，离散信号x
与y的圆周卷积对偶于频域上x与y离散傅里叶变换（DFT）的乘积。用公式表达就是
............
所以，gaussian blur可以对原图和gaussian kernel的图像做DFT，按像素乘起来，再做一
次逆DFT。这种方法和gaussian kernel的半径无关。所以一般在需要超大半径模糊的时候，
速度快于传统的separatable gaussian blur。用DFT做卷积的另一个好处是，同样用这个算
法/代码，就能做反卷积！改成DFT{x} / DFT{y}，其中x是已经经过模糊的图像，y仍是
gaussian kernel的图像，照样那么做，就能得到清晰地图像。唯一需要的参数就是
gaussian kernel的半径。这个需要根据实际情况动态调整。做好的话，就能像CSI那样做实
时连续的模糊到清晰的还原。当然，因为在模糊的过程中很多信息已经丢失，这里得到的是
个可能的原图。换句话说，存在两个不同的输入，模糊后图像相同。这时候用这个算法是无
法得到正确结果的。而且，FFT可以在GPU上实现，即便是手机级别的GPU也能做到接近实时。
所以，可以做一个deblur的camera app，然后，大家都知道怎么用了。

** 1.27 Useful inequalities in statistics

*** Useful inequalities in statistics
Here then, cerebrating, is a list of inequalities I would wish to know, if I
were a graduate student working on statistical theory today. They are generally
grouped by topics; analysis, matrices, probability, moments, limit theorems,
statistics.

1	Cauchy–Schwarz
2	Jensen
3	Hölder and triangular
4	Fatou
5	Bessel
6	Hausdorff–Young
7	Basic Sobolev inequality in three dimensions only
8	Frobenius
9	Sylvestre
10	Determinant bounds, e.g., Hadamard
11	Kantorovich
12	Courant–Fischer
13	Boole’s inequality, from both directions
14	Chebyshev and Markov
15	Bernstein
16	Hoeffding in the Rademacher case, 1963
17	Bounds on Mills ratio from both directions
18	Upper tail of Binomial and Poisson
19	Slepian’s lemma, 1962
20	Anderson’s inequality on probabilities of symmetric convex sets, 1955
21	Rosenthal, 1970
22	Kolmogorov’s basic maximal inequality
23	Basic Berry-Esseen in one dimension
24	Le Cam’s bound on Poisson approximations (Le Cam, 1960)
25	DKW with a mention of Massart’s constant (Massart, 1990)
26	Bounds on expectation of normal maximum from both directions
27	Comparison lemma on multinormal CDFs (Leadbetter, Lindgren, and Rootzén, 1983)
28	Talagrand (as in 1995, Springer)
29	Inequality between Hellinger and Kullback–Leibler distance
30	Cramér-Rao
31	Rao–Blackwell (which is an inequality)
32	Wald’s SPRT inequalities.

Truly going back to my student days, I recall how useful matrix inequalities
were in that period, when linear inference was such an elephant in the room.
Inequalities on CLTs and metrics played pivotal roles in the sixties, and then
again, as the bootstrap and later, MCMC, emerged. Concentration inequalities
came to the forefront with the advent of empirical process theory, and then as
high dimensional problems became important. It seems as though the potential of
analytic inequalities in solving statistical and probabilistic problems hasn’t
yet been efficiently tapped. The recent book by Peter Bühlmann and Sara van de
Geer (2011) has many modern powerful inequalities. There are of course new
editions of the classics, e.g., Hardy, Littlewood and Pólya (1988), Marshall,
Olkin and Arnold (2011).

Quite possibly, on another day I would include some other phenomenal
inequalities, and drop some that I chose today. Can anyone vouch that
Efron–Stein (1981), Gauss (for unimodal distributions), FKG (Fortuin, Kasteleyn,
Ginibre, 1971), Chernoff ’s variance inequality (1981), or a basic prophet or
log-Sobolev inequality, or even a basic Poincaré, need not be in the essential
list? Defining what is the most useful or the most beautiful is about the most
hopeless task one can have. Beauty and use are such indubitably personal
choices. We have, in front of us, an ocean of remarkable inequalities. You can’t
cross the sea, said Nobel Laureate Poet Tagore, merely by standing and staring
at the water. I figure I need to jump!

*** Looking forward to see the match of Lee Sedol vs AlphaGo this March!

* Feb

** 2.4 Princeton vist with Yitong & the movie *Room*

** 2.5 *学而不思则罔，思而不学则殆*

*** thoughts on reading books like *数学与联想* ， *啊哈灵机一动*
近来想起了当年读《数学与联想》，《啊哈灵机一动》，/Basic Algebra/(Jacobson)这些
书时探索心超强求知欲旺盛的时候。也有点重新发现了如何读书如何求知。加上最近读
Rubin的 /Causal Inference/ 以及Lugosi的 /Concentration Inequlities/ 很有感觉，使
我相信自己仍能做一个热爱探索求知的人。

*** /学/ , /思/ 还有 /表达/ 三者的关系
*** 火花卷首语

塞林格写过一部名作叫《麦田里的守望者》，里面的主人公是一个被学校开除的中学生，他
貌似玩世不恭，厌倦现存的平庸的一切，但他并非没有理想。他想象悬崖边有一块大麦田，
一大群孩子在麦田里玩，而他的理想就是站在麦田边作一个守望者，专门捕捉朝悬崖边上乱
跑的孩子，防止他们掉下悬崖。

我很喜欢“守望者”这个名称，它使我想起守林人。守林人的心境总是非常宁静的，他长年与
树木、松鼠、啄木鸟这样一些最单纯的生命为伴，他自己的生命也变得单纯了。他的全部生
活就是守护森林，瞭望云天，这守望的生涯使他心明眼亮，不染尘嚣。“守望者”的名称还使
我想起守灯塔人。在奔流的江河中，守灯塔人日夜守护灯塔，瞭望潮汛，保护着船只的安全
航行。当然，与都市人相比，守林人的生活未免冷清。与弄潮儿相比，守灯塔人的工作未免
平凡。可是，你决不能说他们是人类中可有可无的一员。如果没有这些守望者的默默守望，
森林消失，地球化为沙漠，都市人到哪里去寻欢作乐，灯塔熄灭，航道变为墓穴，弄潮儿如
何还能大出风头？

人做事情，或出于利益，或出于性情。凡出于性情做的事情，大都仅仅是为了满足心灵需求，
如写作、艺术欣赏、交友等等。我们做这个主页也是如此，愉快是最基本的标准。如果什么
时候我们在这里找不到愉快，就必须怀疑是否有利益的强制在其中起着作用，使性情生活蜕
变成了功利行为。火花是这样一个地方，它不想在踌躇满志的游戏精英网站中挤自己的一块
地盘，而是很安静的，与世无争的，但也因此在普遍的热闹和竞争中有了存在的价值。我们
只想开辟一块园地，让火炎玩家们找到回家的感觉。

如果一个人有自己的心灵追求，又在世界上闯荡了一番，有了相当的人生阅历，那么，他就
会逐渐意识到自己在这个世界上的位置。世界无限广阔，诱惑永无止境，然而，属于每一个
人的现实可能性终究是有限的。你不妨对一切可能性保持着开放的心态，因为那是人生魅力
的源泉，但同时你也要早一些在世界之海上抛下自己的锚，找到最合适自己的领域。一个人
不论伟大还是平凡，只要他顺应自己的天性，找到了自己真正喜欢做的事，并且一心把自己
喜欢做的事做到尽善尽美，他在这个世界上就有了牢不可破的家园。于是，他不但会有足够
的勇气去承受外界的压力，并且会有足够的清醒来面对形形色色的机会的诱惑。我们当然没
有理由怀疑，这样的一个人必能获得生活的充实和心灵的宁静。
*** need to install /ispell/

*** *你喜欢哪种类型的数学和统计？*

** 2.6 饺子的包法

*** 饺子的包法

** 2.7 过年

*** 新年对自己的承诺

**** 合格的完成thesis毕业！

**** 在自己真正想做的领域找到一份好的工作，不必是大牛公司，但希望是有好同事能很快成长学习的地方

**** 成为一个更好的programmer!

**** 成为更好的problem solver!
**** 感情有进展
*** 狼人杀的策略
** 2.8 The Danger of Copy-and-Paste Learning
*** Successfully install and setup the *ispell* problem(Aspell) on my Windows 10
Note that on Ubuntu, the *ispell* is installed by default.
**** From EmacsWiki
Once you’ve set up GNU EmacsW32 you will probably want to add spell checking ability.  aspell is not an especially good choice; but alternatives at this point are unclear. True, it integrates seamlessly with Emacs; but the last version of it for Windows was compiled in 2002 and is hopelessly out of date.

Although it might be out of date it seems to work well. I installed Aspell according to the instructions below, yesterday (today is 2015-09-23), and it works fine, in a quite recent Emacs 25. – MaDa

Setup for 64-bit Windows 7
First you need to download and install both the aspell executable and at least one dictionary from http://aspell.net/win32/.  These will be two separate downloads, be sure to get both.  Under the 64-bit version of Windows 7 the default install directory for both of them is “C:\Program Files (x86)\Aspell\dict\”.  “C:\Program Files (x86)” is used for 32-bit executables, while “C:\Program Files” is for the 64-bit ones.

Next we need to make a series of changes in your InitFile.  You need to add the path of the aspell exec to your emacs exec-path.  I tried the path string without the C: at the beginning but it did not work consistently.

    (add-to-list 'exec-path "C:/Program Files (x86)/Aspell/bin/")
We need tell emacs to use aspell, and where your custom dictionary is.

    (setq ispell-program-name "aspell")
    (setq ispell-personal-dictionary "C:/path/to/your/.ispell")
Then, we need to turn it on.

    (require 'ispell)
Lastly you need some way of invoking it.  “M-$” is the default method, which will check the word currently under the point.  If a region is active “M-$ will check all words within the region.  However, I like to customize all the keybindings.  So, here’s an example to use it with FlySpell:

    (global-set-key (kbd "<f8>") 'ispell-word)
    (global-set-key (kbd "C-<f8>") 'flyspell-mode)
*** The spacemacs manual *inside* spacemacs is a good resource to learn org-mode!
check it out inside spacemacs yourself!
*** install clojure(inside *lein*) on Ubuntu
to call clojure in CMD, enter *lein repl*
*** spacemacs *shell* layer
SPC ‘	Open, close or go to the default shell
SPC a s e	Open, close or go to an eshell
SPC a s i	Open, close or go to a shell
SPC a s m	Open, close or go to a multi-term
SPC a s t	Open, close or go to a ansi-term
SPC a s T	Open, close or go to a term
SPC m H	browse history with helm (works in eshell and shell)
C-j	next item in history
C-k	previous item in history
*** 罗平县
罗平县是中国云南省曲靖市下属的一个县，位于滇、黔、桂三省交界处，素有“鸡鸣三省”、“滇黔锁钥”、“滇东明珠”之称。
*** setup the auctex & Okular syncing feature on Ubuntu spacemacs
**** the script
  ;; set up tex pdf viewer
  (cond
   ((string-equal system-type "darwin")
    (progn (setq TeX-view-program-selection '((output-pdf "Skim")))))
   ((string-equal system-type "gnu/linux")
    (progn (setq TeX-view-program-selection '((output-pdf "Okular"))))))

  ;; sync between auctex & Okular
  (setq TeX-source-correlate-mode t)
  (setq TeX-source-correlate-start-server t)
  (setq TeX-source-correlate-method 'synctex)
  (setq TeX-view-program-list
        '(("okular --unique %o#src:%n`pwd`/./%b")    ;; do you understand this line?
          ("Skim" "displayline -b -g %n %o %b")))
*** The Danger of Copy-and-Paste Learning
I have mentioned above that for small code, you can copy-and-paste and tweak to
learn what the code does. However, make sure that you understand what the code
does, line by line. This might not help you now but it will in the future. At
this point, try to explore what the default settings of the LaTeX classes book,
article and report have to offer. In most cases, you will be working with the
article class a lot.

What helps me when learning a new code is I comment on what each line does. I
find this helpful especially coming from a non-programming background. There are
instances, too, that copy-and-paste approach introduces invisible characters
that introduce errors. In the long run, typing the code character-by-character,
line-by-line makes you think more about what goes into your code and what fix
you can do in instances of errors.
*** Revisit Emacs' *bookmark* feature later
Emacs bookmarking makes use of three things that are related but different: a
bookmark list, a bookmark file, and a bookmark-list display. Understanding these
is important to using Emacs bookmarks. They are explained at Bookmark Basics.

Some bookmarking commands to get you started:

‘C-x r m’ – set a bookmark at the current location (e.g. in a file)

‘C-x r b’ – jump to a bookmark

‘C-x r l’ – list your bookmarks

‘M-x bookmark-delete’ – delete a bookmark by name

Your personal bookmark file is defined by option ‘bookmark-default-file’, which
defaults to `~/.emacs.d/bookmarks` in the most recent Emacs versions and to
`~/.emacs.bmk’ in older versions. The file is maintained automatically by Emacs
as you create, change, and delete bookmarks.

The bookmark list (buffer ‘*Bookmark List*’) is like Dired or BufferMenu for
bookmarks. You access it using ‘C-x r l’. (Emacs sometimes calls it the
“bookmark menu list”, which is a misnomer.)

Some keys in ‘*Bookmark List*’:

‘a’ – show annotation for the current bookmark
‘A’ – show all annotations for your bookmarks
‘d’ – mark various entries for deletion (‘x’ – to delete them)
‘e’ – edit the annotation for the current bookmark
‘m’ – mark various entries for display and other operations, (‘v’ – to visit)
‘o’ – visit the current bookmark in another window, keeping the bookmark list open
‘C-o’ – switch to the current bookmark in another window
‘r’ – rename the current bookmark
*** Revisit YASnippet later
check this [[http://tex.stackexchange.com/questions/51204/working-with-templates/51250#51250][link]]
*** TODO Learn to integrate Org-mode & AucTeX mode for daily writing/brainstorming
The following paragraphs can be found [[http://tex.stackexchange.com/questions/22431/everyday-latex-and-workflow/22443#22443][here]]

*I think outlining and drafting is best done in Org-mode. AUCTeX is best later in the process.*

When drafting you can use Org-mode to outline your document. This is basically
to make some headlines that represent content you want to include in your
document and then you work by filling in content under each headline. The
headlines are foldable so that you may get an overview of your document's
structure. You can also mark the headlines with "DONE" or "TODO" to track your
progress. See for instance this tutorial for details.

Once you are happy with a draft you can use Org-mode's export function to export
the document to LaTeX (you can export from Org-mode with a preamble of your
choice). I have written about this in detail in another answer. Then you can
fine-tune the document with AUCTeX. Note that AUCTeX also has an outline feature
for getting an overview of the document.

The idea for this approach is to take advantage of Org-mode's functions that
eases the process of recording, organizing and developing ideas and also benefit
from AUCTeX many functions that helps in editing LaTeX files. I believe that
this is a good approach but it requires the user to know the basics of Emacs,
Org-mode and AUCTeX. Fortunately there are good tutorials and manuals for them.
One just need to know the basics, which are not hard to learn, to start out.
Then one can learn the rest as one goes. For how to learn Emacs and some more
notes on workflow see A simpleton's guide to (...)TeX workflow with emacs.
*** TODO think about the global structure of the *thesis*
** 2.9 *Aha! Insight*
** 2.10 *Kata* challenge & efficient coding
** 2.11 first discovery of gravitational wave
*** the pronunciation of *the*
通常发本音，只有在后面的单词是元音开头时才发thi，元音的话就要自己看书啦，不过基本上什么a,o,u,e开头的大部分都是元音开头的单词。
另外强调的时候也可以发thi ,还是那句话，专业。另外，搞笑时一般也发thi
** 2.15 install mysql on windows 10, starting to learn SQL
** 2.19 唯有大慈大悲手段，方能做出断爱等事
*** 如何评价弘一法师「遁入空门而抛妻弃子」的行为？
作者：王路
链接：https://www.zhihu.com/question/21041918/answer/21034906
来源：知乎

原先看过一个俞敏洪的访谈，访谈里对弘一法师推崇备至。推崇完了又感慨：他老婆带着女
儿在寺庙门口哭，他就是不出来，换我肯定做不到。

这么做是残忍。但成佛需要这种残忍。这种残忍不是对别人残忍，更是对自己残忍。圜悟克
勤禅师说，要有杀人不眨眼的手脚，方可立地成佛。李叔同就有这等手脚。

当年李叔同和夏丏尊在同一所学校任教，夏丏尊是舍监，宿舍丢了东西，夏丏尊问李叔同如
何是好，李叔同想出了一个办法：“你贴出告示请偷盗者出来，说倘偷盗者三天不出来，我
作为舍监监管不力，当自杀谢罪。” 李叔同又说，不过，三天之后若偷盗者不出来，你必须
自杀。夏丏尊想想还是放弃了。用佛教里的话说，李叔同天生有佛缘，这或是得益于过去无
量劫来的修行和亲近善知识。至于残忍，也是不得不残忍。在佛家看来，所有的烦恼和痛苦，
归根结蒂只有两个原因：无明，有爱。断爱，是断除烦恼的第一步。世俗之人眼中的残忍，
佛家眼里恰恰是慈悲。因为“爱别离”与”求不得“之苦，是贪著“爱取有”而生的业果。有爱便
有苦。

即便是从世俗义谛上来说，如果你不再爱一个人，那个人又深爱你，你不予割舍才是对她最
大的残忍。*因为你是有能力主宰的一方，而她绝无主宰自己的力量*。倘你不予割舍，便是给
她机会造作新的业，再遭受更多的苦果。李叔同不再见妻子，只是截然斩断过去，不给彼此
再造作新业的机会。唯有大慈大悲手段，方能做出断爱等事。
** 2.21 plan to do leetcode problems
*** advise from Zhihu
**** 1 推荐流程
著作权归作者所有。
商业转载请联系作者获得授权，非商业转载请注明出处。
作者：Zhang Justin
链接：https://www.zhihu.com/question/26243279/answer/32459565
来源：知乎

leetcode蛮有用的，我当时刷了80%，感觉对所有面试题都能短时间给一个大概的答案。没
在国内找过工作，所以不好说。大家干这行的，如果想换工作，都会去刷题，因为面试能力
和你平时的工作能力其实差别挺大的。你表示自己能熟悉各种machine learning，随意实现
dbn，rbm，q-learning蒙特卡罗，可一段时间不刷题，一下碰上写个thread-safe circular
linked-list还真一下反应不过来。。。我觉得题主提问是求面经，而且是问我们寻常人该
怎么准备面试，也不是来看几位大牛吹水的。我就分享下自己找工作时候的一些准备过程。

认真看了一本算法书，整理了一下自己的算法体系，像算法导论，或者Algorithm Design
by Jon Kleinberg 也挺不错的。花一周认真看看，如果你连几个search，tree都不熟的话
还是多花点时间。。好处是你给自己建立了一个自洽的算法脉络，以后看面试题，或者处理
其他一些现实问题，你都会不由自主的去把问题抽象化，然后归类，我自觉这种思考方式使
我受益良多。

看一下Cracking the code interview.这本书大家应该都说烂了，但这本书长盛不衰必然也
是有理由的。它的题量不多，书里废话也挺多。但它的好处是，它做了一个整理面试题然后
归类的过程，而且基本把你可能遇到的所有面试题类型都覆盖了。然后开始刷

leetcode吧，从简到难，认真刷一遍。建议不要用任何ide，打开没有error check的text
editor（emacs，vim， notepad++ etc)


 最好在有几个可以吹水的领域。因为面试不是一个单纯做题的过程，对于我们平凡人而言，
既然不能一直秒杀面试官，那就想得正常点，和面试官交个朋友。而做技术的，大多数都乐
意结交那些知道一些自己所不懂领域的人。我记得我面的时候，还给人划过Android整个
system stack，从dalvik画到kernel，还有人跟我聊在microkernel system design之类的。

保持一个积极的心态。我知道知乎有很些大神谈面经就是“我从来没被拒过“，但你要相信，
这世界上还是平凡人居多的。我的朋友，包括我自己，在面试中都是一个越挫越勇的过程。
像我一个朋友，他被google，twitter，apple，microsoft都拒过，但最后去了Facebook，
还有一个朋友被google，square拒过，最后拒了amazon去了一家startup，现在已经被某大
公司收购，走上高富帅之路。我被facebook，amazon拒过，google intern拒过一次，但
microsoft就走的很顺，后来google很奇葩的把我面试时间schedule错了，我过了第一轮，
签了MS就不再面了。所以无论遇到什么困难，都要保持乐观，你不是一个人，平凡人也有很
多，要相信自己。
**** 2 按tag刷题
著作权归作者所有。
商业转载请联系作者获得授权，非商业转载请注明出处。
作者：Lou 乎
链接：https://www.zhihu.com/question/36738189/answer/69420404
来源：知乎

按照tag刷起来挺好的。

举个例子：比如复习链表的内容，就选Linked List这部分的23个题目。刷完之后可以再总
结一下常用的方法和数据结构构造方式。总之不是为了刷题而刷题啊，是为了弥补一部分的
知识去做。
** 2.22 The *Devils* are often in the *Details*, SICP is really a fantastic book!

*** backward jump to higher order heading in Org Mode
Use "C-c C-u"

***  The *Devils* are often in the *Details*
So, get your hands dirty!

*** *Less is more* + "奔" + "浅尝辄止"
把这三种基本态度铭记于心，时时映照。

*** SICP example of the picture language
 虽然有些detail还需再深入思考，但目前所体会到的东西已经给我一种醍醐灌顶，眼界大开的感觉。
**** my thoughts
1. The design with different layers of languages not only powerful software
engineering idea, but can also serve as a general philosophy and be applied to
daily life.
2. How to judge/compare the representation power of a/two language/languages?
** 2.26 I still remember some expressions of math analysis teacher --- professor *Bahri Abbas* 
budge 让步；改变主意
*** Abbas Bahri

**** my memory for Bahri, my dear teacher
Unscrew your mind! Free yourself!
Crystal Clear.
Train to see abstract things.
Never take anything for granted.
"You should do it, not say that it is easy." --- Bahri's remark on my homework
The freedom is here.
Always have an idea where you want to go.
Start with an idea, and write your proof to the end.
Just try to do that far.
Draw sth, feel sth, translate what you feel.
Genius + Hard Work
The hidden thing
Math is an experimental science, and definitions do not come first, but later on.
"We guide by intuition and march the road to our destination with the help of *rationism*"
When you are delighted by some intuitions, then finally try to calm down and ask :"give an example to illustrate".
**** my comments on Reddit 
"I had him for math analysis 4 years ago. He is really an enthusiastic teacher and I would always remember his emphasis on "Crystal Clear" mathematical thinking."
**** an interview I found on the Internet  
1.   Tell us about yourself and your specialty or research
 I am a mathematician, born in Tunisia. I have four children. My wife is from Italy. My area of expertise is Non-linear Analysis.....
 
 2.   What were some of the milestone junctures of your life as a scientist?
 I can see two of them: the time I spent in Paris, France, listening to talks at the College de France, within the Analysis and Partial Differential Seminar of Jacques-Louis Lions (who inherited the seminar from Jean Leray); the time that I spent with my students at my home in Tunisia, where I used to spend six months every year in the nineties, laying a foundation for a school in Non-linear Analysis.
 
 3.   What are the most important areas you are working on nowadays?
  Contact Form Geometry, Conformal geometry, Yamabe-type problems.
 
 4.   Where do you see science should opt to? i.e., which direction, it should direct its attention to?
  I do not know.
 
 5.   Do you have/had role model scientists?
  No.
 
 6.   Some say: that after the unique generation of Einstein, Schrödinger, Planck, Bohr & others, science was not able to come with breakthroughs.  Do you agree?  Explain pls.
  I disagree. Breakthroughs have various dimensions; it takes a lot of time and a lot of patient work of generations of scientists to come to turning points in the thinking.
 
  7.   Is philosophy for scientists a luxury or a necessity?
  A hobby and a necessity for me.
 
 8.   What is the societal role of scientists?  Are we doing enough or we are lagging behind?
  I do not know.
 
 9.  Where the emphasis of developing countries (Third world) should be: Solving the immediate problems or indulging in basic research?
  Both.
 
 10. Are distinguished scientists made or they are just born?
  Made essentially.
 
  11. What are some of the most fascinating discoveries scientists have made in your area during the last 20 years.
 The understanding of non-compact phenomena.
 
 12.  Are you optimistic about the role of science & scientists in contributing to world problems such as dwindling economies, wars, famine, abuse of natural resources, polluted environment?
  Yes
 
 13.   Some science education specialists say the bad image of science in the eyes of public has to do partially with inappropriate curriculum; i.e. content-driven instead of context-driven and this is the result of our focus to prepare students for general exams such as SAT, GRE, International Olympics…etc?  What do you think?
  I do not know.
** 2.28 计划开始增肌减脂
* March
** 3.1 Latex Tutorial by Indian user group
*** 京口
京口是六朝长江下游军事重镇。京口是镇江古称，西周时属宜的封地，“宜”是吴和吴文化的
发祥地之一，春秋时京口时属朱方邑，后朱方改谷阳。至秦始皇三十七年（公元前210年），
秦始皇东巡会稽，途经京岘山见有王者气，命三千赭衣徒凿断龙脉，以败王气，故改命丹徒
县。京岘山西北有雄伟的北固山，那个时代它的后峰伸入江中，北固山的后峰、中峰、前峰
起伏连绵，前峰环抱着开阔高平地块，古人把前峰一带称之为京，取义为《尔雅》的“丘绝
高曰京”，口指北固山下的江口。东汉末年，孙权称霸江东，于公元209年将苏州的根据地迁
至京口，在北固山前峰筑铁瓮城，号称“京”通称京口。
*** Latex Tutorial by Indian user group
Read the *cross reference*, *floats(table & graphics)* chapters today. Really illuminating reading experience.
*** 学习emacs能很好的提高工作效率吗？
作者：子龙山人
链接：https://www.zhihu.com/question/38484391/answer/88845653
来源：知乎

我又要来安利一发我录制的视频了: https://github.com/zilongshanren/Spacemacs-rocks/issues/5

作为一个5年vim，2年emacs用户，我来谈谈我的一点看法吧。楼主怀疑学会emacs是否真的
有助于提高工作效率。相信很多人都会有此一问，甚至一些已经有好几年emacs经验的用户。
因为hack emacs实在是太有诱惑力了，每当我成功hack emacs之后，我都非常有成就感，这
不是解决一两个bug所能带来的，这也是emacs happy hacking的魅力。但是有时候hack真的
是很费时间，可能不知不觉一个小时就过去了。所以一定要避免在工作时间去调教你的编辑
器。就像其他回答所说的，你利用别人打游戏的时间折腾是非常划算的。折腾emacs绝对是
time killer。另外我觉得一定要融入社区，不要蒙头瞎折腾，像我现在几乎不折腾了，因
为我用spacemacs。要提高工作效率关键还是对于工作时间的利用，我用org mode来做时间
管理，目前效果还不错。工作中写代码经常用到查找文件，搜索，跨文件搜索和替换，这些
emacs都很强。偶尔写java和oc,我也使用IDE，登录服务器我也用vim。这些都是工具嘛，用
的顺手，能快速解决手头问题才是王道。最后，折腾的过程才是emacs党最大的收获。我这
里就不展开了。最后，如果你不是geek，只用windows，不想折腾，用IDE搞定一切，偶尔使
用命令行，其实不折腾也行，编辑器最终也只是个工具而已。
** 3.2 At what *level* do you think/design/construct(etc.)?
*** At what *level* do you think/design/construct(etc.)?
Sometimes, this is the key question when you got stuck.
Maybe it is just because you're not at the *right level of abstraction*.
** 3.3 insert/display images in org mode
*** insert/display images in org mode
if you add [[myimage.png]], org mode will use the file myimage.png as an inline
image for myimage.png. You can then run M-x org-display-inline-images to display
your inline image.

adding (setq org-startup-with-inline-images t) to your .emacs will make image
inlined on opening a org buffer. M-x org-redisplay-inline-images will refresh
inlined image if needed.
*** what is the "unit time" in this particular algorithm problem?
*** the power of "wishful thinking"
** 3.4 study spacemacs documentations & relearn *gnus*
*** study spacemacs documentations & relearn *gnus*
**** the *SPC h* key is very powerful
Like *SPC h SPC*, *SPC h d f*, *SPC h d v*
** 3.5 Peter Liang, Zootopia
*** To Wu Rui Ge
吴锐哥你这问题一来就问“怎么看”这真不是一两句话能表达清楚的事情，所以那天看到你消息觉得短时间说不清就放一边了。梁警官的事件最近我没有跟踪，但总的来说我觉得他很大程度上是被纽约警局所牺牲的。因为前两年和种族歧视有关几次骚乱的发生，所有涉案警官都没有被起诉，这次给人的感觉至少是纽约警局选择性地放弃了梁警官。

在大部分美国人的印象里，亚裔属于“好好”公民，很多时候也不是特别团结地维护自生的权益，这在我看当然是偏见，但若非有无数的例子也不会给人以这样的印象。我觉得这次梁警官的事件至少让我开始思考在美国这个地方，少数群体应不应该抱团，应该怎样抱团这些问题。以前我觉得无关紧要，现在看法有些改变。

华人不爱抱团，总爱彰显自己特别公平公正，大是大非帮离不帮亲，这在目前阶段非常不利于整个群体被接纳。这次的梁警官事件我在微信转发的意思也是希望周围的朋友一起关注这件事，做些力所能及的事情，改变很多美国人多亚裔的偏见。我个人没有用“歧视”这个词是因为我接触过很多不错的美国人，我觉得美国社会中能够理性思考的本土人还是有很多很多的。
*** Zootopia
** 3.9 coder的成长
*** debugging
老鸟和新手的一个很大区别来自于debug的能力。其中最主要又可以从两方面看出来：
1. 从高层往底层找错。
2. 科学方法。

很多新手遇到程序执行结果不对（尤其是图形程序员），先认为是机器毛病（浮点精度、硬
件故障），然后认为是驱动有错，再认为是系统有错，最后才开始排查自己的程序。其实
99%的情况下是自己程序有错，然后那1%里面的99%是系统有bug，再接着那1%里的99%是驱动
有bug，最后到硬件问题，已经微乎其微了。应该从高层往底层查，而不是反过来。

debug一般来说是知道现象，但原因未知。这一点和很多自然科学的情况一样，所以完全也
可以用科学的方法来：提假说->根据假说做出预言->做实验肯定或否定预言。对应于debug，
那就是假设是某个地方有问题，那么推断它一定会导致除了你看到的现象之外的其他现象，
运行程序看你的推断是否成立。掌握这个方法后debug不在变成瞎找瞎试，而是有迹可循有
系统可依赖的方法。
*** coder的成长 
用三年时间成长为顶级 Coder 是有可能的。

不信？排名第二的答案是酱紫说的，快速成为顶级 Coder，你需要的是「自律」和「坚持」。
请注意，我们说的是「Coder」，而不是「Programmer」或「Software Engineer」。对于
Coder，我们是有客观评价标准的，那就是参加「编程比赛」。

楼主研究了一下所谓的「编程比赛」或「算法大赛」：除了国内的各种程序设计大赛，如百
度之星、有道难题，更推荐参加国外的编程比赛网站，如「topcoder」、「codeforeces」。
这些网站上每个月都有比赛，只要你有一台能上网的电脑就可以免费参加，和全球的 Coder
竞争，赢得了比赛还有美金拿哦。

简单来说，你至少需要做到以下几点：• 进入 topCoder 的练习室，每天花 4-6 个小时练
习编程。

• 制定一个计划，比如：每天解决 10 个初级问题，每周搞定 3 个中级问题、1 个高级问
题。

• 如果在某个问题上困住了，马上去论坛求助。要知道，问问题体现了你的思维逻辑，问出
好问题也是需要练习的。试着每周在问答网站stack over flow 上问一个问题吧！

• 不要闭门造车，把你的代码展示给别人看，他们提出的意见会让你事半功倍，推荐免费网
站 coder review。

• 学会看别人的代码，看代码其实比自己写代码更难，但是高手是可以轻易调用别人的代码
的，推荐 github，可以轻松地找到海量的开源代码。

• 建议采取一些外部的措施克服拖延症，比如开通一个博客、或微博，每天在上面记下你今
天做过的一件重要的事情，保证每天晚上都带着巨大的满足感入睡。

如果坚持做到以上这些，你完全成为一名顶级 Coder。需要注意的是，编程比赛关注的是算
法能力；但是，要成为一名Programmer 或 Software Engineer，你还需要项目经验。正如
Facebook 喜欢雇佣所谓的「Full stack programmer」，就是一个人从设计、到交互、html、
css、javascript、server、sql、架构，以及数据统计都能做。成为 Full Stack
Programmer 最好的方式就是不断做个人项目。

参加 Hackathons 或 game jams 就是锻炼项目能力的好方法。在规定的时间内，一群开发
者分享、讨论、组队、分工协作，用创意思维完成项目任务。无论是制作一个游戏，还是网
站，在整个项目的进程中，你会不断经历发现问题、解决问题、获得经验的过程，从而保证
在实际工作中也能轻松解决问题。

总之，楼主以为，入行时间并不是衡量人才能力的绝对标准，碌碌无为的「老人」在各行业
都不鲜见。在 3 年之内能否成长为一名优秀的 Coder 或Programmer，其实取决于你对所做
事情的理解程度。对所做事情理解的越深，你就会做的越好。

成为一名优秀的程序员和成为其他行业的高手一样，都需要不停地学习、练习、反省和总结。
这不仅是最初 3 年的要求，而是贯穿整个职业生涯的要义。

所以，初级程序员想要获得快速成长，一定要拥有不怕麻烦的责任心，和不满足于现状的上
进心。
** 3.12 AlphaGo defeated Lee Sedol
*** Google vs Facebook（田渊栋）
我半年前从谷歌X的无人车组跳到Facebook的人工智能实验室（FAIR），感触良多，这里写
一些分享给大家。

虽然F和G并称一流的IT公司，但是其实内部是很不一样的，甚至可以说完全相反。加入FB之
前，问过很多朋友，大家的意见综合起来是FB有点“乱”，没有统一的平台，各组管各组忙，
代码质量比G差很多，文档也少。这听起来挺吓人的，但认真想想，反过来说乱才有机会。G
最大的问题恰恰是一切都井然有序，能出大成果的地方都出完了，员工就像螺丝钉，只要在
自己的岗位上做好修补就行了。

F没有五花八门的内部工具，用的大多是开源的略作修改，所以F的员工流动性非常大，因为
工具和平台熟悉了，到外面一样可以用。举个例子，我半年前加入，现在已经比三分之一的
员工来得早了。相比之下G的内部工具太多，待久了习惯了这些工具，再加上成年累月的股
票，往往跳走不易。我们组的分布式平台当然没有G的复杂，还有好多地方做得不好，然而
正因为简单才容易理解，也容易给它动手术学到东西。那个写平台的人，往往就是坐在邻座
的邻座的的工程师，哪天需要加新功能了，打个招呼就行了，甚至自己可以动手写完让他审
核。要是在G碰到这样的问题只能举双手投降，因为那是远在校区另一头某个人某个组的事
情。

F太多项目可以做，合作也很容易，往往是吃顿饭大家聊聊就开干了。而在G大家抢项目做，
员工并没有太大的自由度，一般指望老板还有老板的老板和别的组抢。我加入F这半年，在
没有提前通知自己老板的情况下，单独和产品组的成员合作了一个项目，思路简单但是非常
有用，单机处理100G数据，花了三个月发布了，还上了VP和Engineer Director当月的Top
List，备受大家关注，这在G是完全不可想像的。

作为研究员，我再也不用为代码格式和变量名字伤脑筋，再也不用因为别人没来及审核自己
的代码而无法工作，因为存在一个实验目录，可以不经审核提交代码。G对代码的严格对公
司是有好处的，但它太过死板的规定经常限制发挥。我有时真弄不明白，为什么在两三天后
审核回来时，还要改变量名改接口设计呢？我分明已经在这个基础上写了四五个扩展了，再
花时间改回去，真心是很伤士气和进度的。

这半年说话比原来多了。作为码工只要和同事把现有的平台搞清楚，然后照着写程序就行了；
但作为研究员需要不停地和各种人交流，同事，访问教授，实习生，理解他们的工作，提出
意见和建议。你不愿意说话，别人（甚至Yann）会找你说话，久而久之就发现，自己永远得
要对自己的工作，即便是正在进行中的工作，有一番概括和推广，自己的工作得要自己吹起
来，别人才会知道并且欣赏，长远来说，这对个人的发展更有利。

我们组做深度学习主要用torch/lua。一开始学习曲线比较陡峭，但用惯了则相当好用。这
个语言有趣的地方是，它很简单，简单到你可以理解语言设计的每个细节，对每个出现的
bug都会有相对深刻的理解。我曾帮过我们组的工程师设计一个特殊的用来做profiling的
lua类，身为研究员还可以在设计上帮到工程师，是挺自豪的。

我加入之后，经常从早上十点干到晚上八九点，然后锻炼完之后回家继续忙，经常周末加班，
带几个实习生再加上做自己的研究。看起来工作强度是更大了，但为了自己的事业，有什么
不可以的呢？最重要的原因是，相比在无人车组一心二用，白天做应用晚上自己折腾研究，
我的内心深处，还是想集中精力花几年去理解深度学习本身，做一做它的理论框架。我的老
板也非常支持这样长期的研究，这个是FAIR真正让人心动的地方所在。

这两天绩效考核，我老婆评论说我这半年干的事情比在G家一年还多，有产品发布也有研究，
我想这就是真正把兴趣用在工作上的结果。我还记得自己最后一天在G的日子，HR小姑娘最
后问我为啥离开，是不是因为X的工作太辛苦，需要一些工作和生活的平衡？我笑了笑，敷
衍了几句，心里想起了《冰与火之歌》里的那一句台词——

雪诺，你什么也不懂。

2015-07-14
** 3.13 Lee Sedol strikes back on my birthday!
*** 小李，人类的胜负师
这几天真是一个跌宕起伏的故事，从轻敌到惨败，再到不屈不挠的反杀，昨天天才少年的落
寞，和那一句，这是我李世石的失败，不是人类的。到今天战胜alphago狗，不动声色的复
盘，这就是一个人类可以有的全部自尊，不屈，才能，冷静。可以想象以后会有许多以这为
原形的文学吧。是的，我们从未放弃。

作者：张三
链接：https://www.zhihu.com/question/41325834/answer/90532996
来源：知乎


虽然是老生常谈，还是忍不住感叹一句。处于上风的时候（做顺手的项目，交佩服自己的朋
友，调戏不爱的姑娘）浑身的机灵劲儿怎么抖怎么有根本不是本事。像李世石那样也得意过
也张狂过，但是在最不得意最不张狂，被虐得体无完肤信心体力都落在最低点的时候，还能
咬着牙槽反戈一击，才算是真男人啊。 --- 木遥
*** Run time, compile time, link time & load time
**** how to avoid run-time error
The following guidelines show how to avoid run-time errors. These are only
guidelines, as the conditions under which run-time errors occur are dependent on
the context of your application.

If, for example, you use the GET function to locate a record, you must be
prepared handle the possibility that a run-time error can occur if there are
situations where no record is found. If you are certain that the specific
context precludes this situation, you can omit handling a possible run-time
error. (The context could be that the existence of a record is verified before
the GET function is used.)

There are two categories of run-time errors:
1) Errors that are related to the use of data types

2)Errors that occur if a function does not succeed in doing what it is supposed
to do

Division by zero does not fit into either of these categories, but it has been
placed in the first one.

You can only prevent some errors (mainly related to data types) from occurring.
Other errors cannot always be avoided, but you can write code that shields the
user from the error. Instead of the default error handling (which displays a
message, closes the form that was active when the error occurred, and rolls back
any changes to the database), you can write an error handler that, for example,
gives the user an opportunity to correct the input that caused the error. This
error will display a message that explains why the error occurred.
** 3.16 Have some idea about the vast land beyond *SICP* after read a tutorial introduction to Lambda Cal by *Raul Rojas*
*** vast land beyond SICP and current thoughts 
各种各样的类型推导，想懂得多一点的话已经进入数理逻辑和代数里的范畴论。其中的一种，
即lambda calculus，就已经是functional programming的基石。

我很有兴趣，但我也明白现在这个阶段没有必要也没有时间深入了解，所以大概能通过深入
阅读SICP理解functional programming的原理并能根据原理写一些有用有意思的程序就够了。
以后再图深入Programming Language这个领域。

我觉得今天阅读SICP section 3.1 以及 lambda cal tutorial最大的体会就是————怎样去
定义语言中的“替换法则”确实很subtle，而如果想在语言中引入赋值，那变量环境/域以及
相关scoping rule就不可避免要准确来定义了。
*** 向热爱计算机科学的你推荐SICP(转)
先谈谈关于《计算机程序的构造和解释》（后面简称为SICP）的几个八卦。

本书曾经是MIT本科第一门课的教材。前两年被Python取代，在geek中引发了轩然大波。有
兴趣可以Google一下[sicp mit python]。 本书在Amazon上的评分严重两极分化，五星
（>90）和一星（>50）为主，彻底反正态分布。 本书在Amazon上排名最高的书评出自Peter
Norvig，当然是强烈推荐，顺便狠狠地鄙视了给一颗星的同学们；第二篇出自Paul Graham，
还是强烈推荐。 本书别名紫书（The Purple Book），巫师书（The Wizard Book），或者
干脆The Book。

这是一本什么样的书？

前言说，这是一本给MIT学生的入门级（entry-level）计算机科学教材。作者的出发点有两
条：

语言首先是写给人看的，只是恰巧（incidentally）能够运行。这当然是个修辞，格外强调
代码之可读。 语言的语法，漂亮的算法，数学的分析，这些统统都不重要。最打紧的是如
何控制复杂度（The techniques used to control the intellectual complexity of
large software systems）。

在本书成书的年代（1984），以上言论即使不算正邪不两立，也够的上离经叛道了。

通俗的说，这本书教你如何用最基本的构造和原则，解决复杂和多样的问题。用摄影打比方，
这本书不比较尼康和佳能，不介绍繁杂的机型和参数，不介绍后期处理的技巧。这本书只讨
论光线、色彩和构图，以及如何在不同场景拿捏这些基本原则组合出美妙的照片。


这本书适合初学者吗？

不好说。Amazon上的一颗星评价大多鄙视本书已经过时或者太过高深。我个人看法，它很适
合一部分初学者，但是需要满足几个条件：

热爱计算机科学 有时间和耐心 受过（高中水平）数学和抽象思维的训练

所以，如果只是想领一份程序员的薪水，这本书完全可以略过。并不是说这本书有多么不实
用，只是计算机科学与写代码并不是一码事。

这本书广而不深，讨论到了非常多重要的思想，有些甚至冷不丁出现在注释里（比如Y算子）。
内容安排很照顾初学者，循循善诱；语言直白简单；代码大多简明自然。

至于习题，个人认为只要认真思考，大部分都不是很难，需要耐心多于智力。有时间不妨多
做几道。 这本书适合有经验的程序员吗？

还行。如此庖丁解牛般的讲解，其他书中不多见；内容简单，思想却不过时。另外，国内绝
大部分程序员都从命令式语言入门，不妨接触一些函数式思想，开开眼界。如果时间不多，
至少看看前两章，学习一些解决复杂问题和编写优雅代码的技巧。

为什么我们要学习这本书？因为这本书告诉我们如何抽象。为什么我们要学习如何抽象？因
为抽象是我们控制软件复杂性的重要手段。软件是人类有史以来最复杂的系统。其一、软件
系统本身规模庞大，参与人手众多，难以管理；其二、环境和需求不断变化，且错误难以避
免。

人类无法驾驭过于复杂的事物，于是只能寻找方法简化软件系统：把系统分为许多子部分，
人们开发一个部分的时候，系统其他部分都是一种抽象，无需了解其细节。

本书讨论的就是系统的组织和设计，有哪些方法可以帮助我们控制软件的复杂度。 Scheme
好学吗？

其实Scheme是一门异常简单的语言。直来直去，除了括号多，基本没有旁门左道（比如指针）
和撕心裂肺的语言构造（比如模版、多重继承、Monad）。再者，这本书的内容和具体的语
言基本没有关系，思想才是重头戏。如果实在有顾虑，推荐先读两本薄薄的小册子：The
Little Schemer和The Seasoned Schemer。 这本书到底讲什么？

本书按照内容可以分为三个部分：过程抽象（第一章）；数据抽象（第二、三章）和语言抽
象（第四、五章）。

过程抽象部分比较简单，先介绍了Scheme的基本语法，让读者初步领略函数式编程的风采。
对于有一定编程基础（相信国内极少有人入门就读这个）的读者来说，会有耳目一新的感觉，
原来递归和迭代可以有另一种表现形式，但并不难理解。习题也比较简单，不会用掉太多的
时间。过程抽象的概念也很简单，就是编程语言中的函数，目的是封装计算过程的细节。关
于何时应该用过程抽象的原则是：一切可以定义为过程的计算片段都应该定义为过程。

数据抽象是我认为的本书的核心，也是最值得我们仔细研读的部分。关于数据抽象最直接的
理解就是面向对象编程，如C++，而Java和C#则是更彻底的数据抽象。把一组过程抽象（类
的方法）集中考虑，并加入内部状态（类的变量），就是一个数据抽象。每个数据抽象都应
该把自己的内部对象状态和对象的实现隐藏起来，对外通过一组接口进行消息传递。这样听
起来好像本书与一般的面向对象书没有区别，但实际上，这些都是我自己的总结，书里面不
会把这些概念直接罗列出来，而是通过一个个巧妙的例子，让读者一步步深入，感叹原来A
还可以这样抽象，原来B还可以这样封装。个人认为如果时间有限，读完前三章已经可以领
会本书大部分思想了，后两章可以不读。

语言抽象是指自己发明一门语言，以解决某一特定应用领域的问题。在这一领域中，自己发
明的语言会比其他通用语言更方便。定义了新语言的语法后，就要自己去实现该语言的编译
器或解释器，可以通过现有的语言去构造。这一部分包含了许多编译方面的知识，但又与编
译原理中的构造方法有不少区别，自己看书很容易看得云里雾里，听老师讲课才好一些。大
部分习题很难做，一部分习题非常难。

第一章讨论程序设计的最基本原则：原语（primitive expressions）、组合（means of
composition）和抽象（means of abstraction），以及如何利用这些基本原则化解复杂度。
重点是过程抽象和高阶过程（high-order procedures）。本章的例题十分精彩，抽象和组
合的过程十分清晰。有关递归和迭代的讨论也非常耐读。

第二章讨论数据抽象，即利用基本数据构造复杂结构。Scheme里的基本构造能力只有cons，
但由此可以组合出所有实用的结构。图像语言、符号运算、集合表示、哈夫曼编码和复数系
统都是经典实用的例子。顺带还介绍了data-directed方法，与面向对象中的封装有异曲同
工之妙。

即使没有太多时间，我觉得前两章也值得值得细读。尤其是例子。

第三章主要讨论了状态（local state）和环境（environment model），可变数据结构
（mutable data），以及状态和时间的交互（concurrency和laziness）。前两章用到语言
是Scheme的一个没有副作用的子集，从这一章开始涉及解释器的核心机制，尤其是状态的管
理，及其优缺点。

第四章用Scheme实现了一个简单的Scheme解释器。重点是讨论语言的解释过程，以及如何针
对问题（领域）创造和修改语言，从中可见DSL（Domain Specific Language）的思想。后
三节各自讨论一个工程中不常见但高效解决特定问题的语言变种及其实现。

第五章介绍将Scheme编译为现实中的寄存器机器模型（register machine）。重点不是编译
技巧（Scheme压根不需要文法分析），而是基本构造（条件、过程，等等）对应于寄存器模
型的实现。略带讨论了最简单的垃圾回收。

后三章较深，最好略有一点语言、编译和体系结构的基础，或者多些耐心。 语言会影响思维

如果要问现代数学最重要的概念是什么，那毫无疑问就是函数了，或者更确切地说，是映射。
泛函这个词，或许对非数学系的同学来说有些陌生，但如果写成英语 functional, 看起来
就眼熟多了。狭隘一点地说，泛函就是以函数为参数，返回值是数值的一类函数。看到这里
相信不少同学都发现了，这就是在很多语言中被称为高阶函数（high-order function）的
那个东西。泛函在数学中是如此普遍的概念，现代数学几乎无处不会用到。数学家们很自然
地在集合上添加运算，构造空间；从一个空间映射到另一个空间，创造泛函。对泛函做变换，
构造泛函的泛函等等。

为什么我要在这里提到数学和泛函？因为在我看来， lisp 是一门以表达数学为己任的语言。
正如 SICP 中希望表达的一种观点：语言会影响思维。如果数学推理过程中最频繁应用到的
泛函，在计算机语言中却没有对应的表达，换言之数学思维不能很自然地表述为计算机语言
的话，那么计算机对于数学研究的意义就显得很可疑了，毕竟那时候的计算机可不是用来玩
大菠萝3的。所以这里就有了两拨人，务实的一拨人开发出了 fortran ，力主解决数值计算；
务虚的一拨人则创造了 lisp ，试图一举解决符号计算的难题。在 John McCarthy 所作的
history of lisp 中这样写到：

Then mathematical neatness became a goal and led to pruning some features from
the core of the language.（保证数学上的简洁性成为我们的目标，并因此拒绝了将一些
特性加入到语言核心中。）

This was partly motivated by esthetic reasons and partly by the belief that it
would be easier to devise techniques for proving programs correct if the
semantics were compact and without exceptions.（这部分是基于美学上的考虑，部分是
因为我们相信，紧凑而没有特例的语法才更有可能设计出一种从数学上证明程序正确的方
法。）

之所以讲了这么多关于数学和历史的东西，是因为我觉得在看这本书前，最重要的是理解：
lisp 是什么。而我又一直相信理解一样事物最好的办法就是理解其历史。（顺带说一句，
以上历史都是在看过书以后才找的，所以也是我的血泪教训……）如上所示， lisp 是一门为
了表达数学推导过程而诞生的语言，所以不可避免地使得 SICP 前两章的例子几乎全是数学
问题。代码只是其形，而其神是纯粹的数学。所以这里似乎就陷入了一种两难的境地：如果
执意于写代码的话，那看起来做的都是形而下的工作；而如果只思考问题的数学原理的话，
那姑且不说是舍本逐末，至少也是偏离主题了。在看完 SICP 以后我始终怀着这种疑问而不
解——看的时候是不会有这种感觉的，因为注意力全部纠结于书中的题目了——不过在写这篇书
评时又翻了一下第一章，似乎明白了。

小节1.1写到：

一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框
架，使我们能够在其中组织自己有关计算过程的思想。每一种强有力的语言都为此提供了三
种机制：基本表达形式，组合的方法，抽象的方法。

所以我认为 SICP 这本书最主要的目的，就是“教你用 lisp 的语言，来组织，来抽象，来
表达想法”。从这个意义上来说， SICP 和一本 Learning Python ，或者一本 C
Programming Language 并没有太多的区别，依然讲授的是“用特定的语言求解特定的问题”。
不过略有不同的是， lisp 太特殊了，导致从 c 转向 python 或许不需要太多的思维转换，
但从 c 转向 lisp 却需要对思维习惯大改造一番，这我想就是 SICP 地位如此之高的原因
吧。我也同意，学习 SICP 确实很锻炼思维，以及培养一种更加高度的抽象习惯。其实在看
SICP 的过程中，很多时候我都会感慨，“如果我不是数学系的，这一段到底会怎么理解呢”。
一个典型例子就是习题2.6，初看我也一头雾水，后来才意识到 zero 是 f->id 的泛函，正
是零映射， one 是 f->f 的泛函，正是恒同映射，也就是函数空间的1。如果没有学过泛函
分析的我来看这道题目，估计只能好不容易推导出规律后，感慨于 Church 计数的“巧妙”了。
所以从好的层面来看， SICP 至少能够带来泛函的直观感受，因此我才说 SICP 是一本写给
CS人的泛函数。但是从坏的层面上说，数学抽象毕竟是象牙塔里的产物，当好不容易抽象出
一个优雅的模型却发现手头的语言难以表达或者效率上有种种顾虑的时候，还是很郁闷的吧。

前面貌似说了 SICP 的不少坏话，其实只是想拉低一下 SICP 的评价，至少使得后人不至于
期待过高。SICP 是一本好书，至少是一本有趣的书，这点我是非常赞同的。就冲着她那创
意的封面图和作者头像，每章开篇都会引用一段（非常利于装逼）的名言，以及用半页的篇
幅讲述和主题完全无关的 MIT 第一任校长的生平，想不有趣都难啊。不过我还是世俗一下，
列一下自己看过这本书以后比较"现实"的收获：

对于构造递归式的训练。相信做过的都深有体会…… 列表处理流程，也就是
map-filter-reduce 。 流处理这一节让我终于明白了 generator 的意义。 从另一个角度
看程序和程序设计中的问题 函数式程序设计 多种多样的程序组织方式 丰富多彩的编程模
式 对一些基础问题的理解 ……

关于习题

最后说一下习题，习题的重要性想来大家都很清楚。

本书共有5章，每章都有近100道习题。这本书可以说是时间黑洞。每章分为4-5节，每节有
几个小节，全书有一百小节（即X.X.X）左右。我以小节为单位进行了估算，包括完成习题，
每小节大约需要一个小时。当然不同小节难度不同，有的耗时长些，有的短些。于是读完本
书并做完大部分习题需要上百个小时。再加上听课或看视频教程的时间则会更长。所以我觉
得恐怕只有在校学生才有时间和精力来完成这本书的学习。

不过对于 SICP 来说，我觉得习题未必都要写成代码，在纸上写出思路和关键代码也未为不
可。因为 scheme 的编码效率实在不高（就是 scheme 逼得我给 vim 装上 surround 插
件……），而习题重要的还是整个抽象的过程。另外就是，要找个好一点的解释器，我下了
MIT 的 scheme 解释器发现各种操作太不人性了…… 为什么推荐SICP？

向大家推荐 SICP，不知道有多少人看了，也不知道有多少人明白了，更不知道有多少人惊
叹了。或者你根本不屑一顾，或者你看见 Lisp 那层层括号心生畏惧，又或者你了了一瞥，
觉得没什么精彩之处。那我真的很失望。

我为什么要推荐SICP，而且为什么如此执着？这本不算厚的书带给我的观念，是从未有过的，
是关乎于软件本质的。曾几何时，我觉得我看到了计算机编程书中没有的哲学观，但这一次
我的梦破灭了，那些已经被写进书里差不多快 30 年了。

我现在就来谈谈我的心得，以再次向你展现这本书的魔力。

第一章作为基础，作者并没有象后续章节写太多的软件思想，主要还是介绍 Scheme 语言，
所以草草看去，没什么精辟之处。不过在第一章中，作者用了大量的篇幅来探讨数学问题，
因为他想向你揭示程序设计中的核心哲学：抽象。而数学无疑是最好的例子。

了解数学史的人，应该知道整个数学史，就是一个不断抽象的历史。古希腊人将字母引入计
算，使数学不再只是算术，而且具有表达抽象规则的能力。近代数学对函数和微积分的探求
中，用 f(x) 替代了多项式表达式，函数更一般了，然后 n 维空间、复分析、映射、泛函，
抽象代数、群论，等等等等，直到集合论，摧毁了数学的基石，使数学界再次陷入沉思。

构造程序的方法也是抽象。从最简单的元素开始，基本元素(自演算表达式，包括数字，字
符串和布尔值），然后定义基本过程（基本运算符，四则运算和布尔运算），进一步，自定
义标识符（如同代数），再自定义过程（函数），再将过程作为值参与运算（高阶过程）。
一步步的抽象，形成了整个程序的结构。而我们编程，无非就是从现实世界抽象出模型，再
将模型不断的提炼抽象，属性、方法、类、继承、层次、框架。

编程就是一个不断抽象的过程。我再次把作者在第一章末写下的结论抄在这里，作为最后的
注脚。

“作为编程者，我们应该对这类可能性保持高度敏感，设法从中设别出程序中的基本抽象，
基于它们去进一步构造，并推广它们以创建威力更强大的抽象。当然，这并不是说总应该采
用尽可能抽象的方式去写程序，程序设计专家们知道如何根据工作中的情况，去选择合适的
抽象层次。但是，能基于这种抽象去思考确实是最重要的，只有这样才可能在新的上下文中
去应用它们。高阶过程的重要性，就在于我们能显式地用程序设计语言的要素去描述这些抽
象，使我们能像操作其他计算元素一样去操作它们。”
*** Perils of the Java school(Joel)
Lazy kids.

Whatever happened to hard work?

A sure sign of my descent into senility is bitchin' and moanin' about "kids
these days," and how they won't or can't do anything hard any more.

“You were lucky. We lived for three months in a brown paper bag in a septic
tank. We had to get up at six in the morning, clean the bag, eat a crust of
stale bread, go to work down the mill, fourteen hours a day, week-in week-out,
and when we got home our Dad would thrash us to sleep with his belt.” — Monty
Python's Flying Circus, Four Yorkshiremen When I was a kid, I learned to program
on punched cards. If you made a mistake, you didn't have any of these modern
features like a backspace key to correct it. You threw away the card and started
over.

When I started interviewing programmers in 1991, I would generally let them use
any language they wanted to solve the coding problems I gave them. 99% of the
time, they chose C.

Nowadays, they tend to choose Java.

Now, don't get me wrong: there's nothing wrong with Java as an implementation
language.

Wait a minute, I want to modify that statement. I'm not claiming, in this
particular article, that there's anything wrong with Java as an implementation
language. There are lots of things wrong with it but those will have to wait for
a different article.

Instead what I'd like to claim is that Java is not, generally, a hard enough
programming language that it can be used to discriminate between great
programmers and mediocre programmers. It may be a fine language to work in, but
that's not today's topic. I would even go so far as to say that the fact that
Java is not hard enough is a feature, not a bug, but it does have this one
problem.

If I may be so brash, it has been my humble experience that there are two things
traditionally taught in universities as a part of a computer science curriculum
which many people just never really fully comprehend: pointers and recursion.

You used to start out in college with a course in data structures, with linked
lists and hash tables and whatnot, with extensive use of pointers. Those courses
were often used as weedout courses: they were so hard that anyone that couldn't
handle the mental challenge of a CS degree would give up, which was a good
thing, because if you thought pointers are hard, wait until you try to prove
things about fixed point theory.

All the kids who did great in high school writing pong games in BASIC for their
Apple II would get to college, take CompSci 101, a data structures course, and
when they hit the pointers business their brains would just totally explode, and
the next thing you knew, they were majoring in Political Science because law
school seemed like a better idea. I've seen all kinds of figures for drop-out
rates in CS and they're usually between 40% and 70%. The universities tend to
see this as a waste; I think it's just a necessary culling of the people who
aren't going to be happy or successful in programming careers.

The other hard course for many young CS students was the course where you
learned functional programming, including recursive programming. MIT set the bar
very high for these courses, creating a required course (6.001) and a textbook
(Abelson & Sussman's Structure and Interpretation of Computer Programs) which
were used at dozens or even hundreds of top CS schools as the de facto
introduction to computer science. (You can, and should, watch an older version
of the lectures online.)

The difficulty of these courses is astonishing. In the first lecture you've
learned pretty much all of Scheme, and you're already being introduced to a
fixed-point function that takes another function as its input. When I struggled
through such a course, CSE121 at Penn, I watched as many if not most of the
students just didn't make it. The material was too hard. I wrote a long sob
email to the professor saying It Just Wasn't Fair. Somebody at Penn must have
listened to me (or one of the other complainers), because that course is now
taught in Java.

I wish they hadn't listened.

Think you have what it takes? Test Yourself Here! Therein lies the debate. Years
of whinging by lazy CS undergrads like me, combined with complaints from
industry about how few CS majors are graduating from American universities, have
taken a toll, and in the last decade a large number of otherwise perfectly good
schools have gone 100% Java. It's hip, the recruiters who use "grep" to evaluate
resumes seem to like it, and, best of all, there's nothing hard enough about
Java to really weed out the programmers without the part of the brain that does
pointers or recursion, so the drop-out rates are lower, and the computer science
departments have more students, and bigger budgets, and all is well.

The lucky kids of JavaSchools are never going to get weird segfaults trying to
implement pointer-based hash tables. They're never going to go stark, raving mad
trying to pack things into bits. They'll never have to get their head around
how, in a purely functional program, the value of a variable never changes, and
yet, it changes all the time! A paradox!

They don't need that part of the brain to get a 4.0 in major.

Am I just one of those old-fashioned curmudgeons, like the Four Yorkshiremen,
bragging about how tough I was to survive all that hard stuff?

Heck, in 1900, Latin and Greek were required subjects in college, not because
they served any purpose, but because they were sort of considered an obvious
requirement for educated people. In some sense my argument is no different that
the argument made by the pro-Latin people (all four of them). "[Latin] trains
your mind. Trains your memory. Unraveling a Latin sentence is an excellent
exercise in thought, a real intellectual puzzle, and a good introduction to
logical thinking," writes Scott Barker. But I can't find a single university
that requires Latin any more. Are pointers and recursion the Latin and Greek of
Computer Science?

Now, I freely admit that programming with pointers is not needed in 90% of the
code written today, and in fact, it's downright dangerous in production code.
OK. That's fine. And functional programming is just not used much in practice.
Agreed.

But it's still important for some of the most exciting programming jobs. Without
pointers, for example, you'd never be able to work on the Linux kernel. You
can't understand a line of code in Linux, or, indeed, any operating system,
without really understanding pointers.

Without understanding functional programming, you can't invent MapReduce, the
algorithm that makes Google so massively scalable. The terms Map and Reduce come
from Lisp and functional programming. MapReduce is, in retrospect, obvious to
anyone who remembers from their 6.001-equivalent programming class that purely
functional programs have no side effects and are thus trivially parallelizable.
The very fact that Google invented MapReduce, and Microsoft didn't, says
something about why Microsoft is still playing catch up trying to get basic
search features to work, while Google has moved on to the next problem: building
Skynet^H^H^H^H^H^H the world's largest massively parallel supercomputer. I don't
think Microsoft completely understands just how far behind they are on that
wave.

But beyond the prima-facie importance of pointers and recursion, their real
value is that building big systems requires the kind of mental flexibility you
get from learning about them, and the mental aptitude you need to avoid being
weeded out of the courses in which they are taught. Pointers and recursion
require a certain ability to reason, to think in abstractions, and, most
importantly, to view a problem at several levels of abstraction simultaneously.
And thus, the ability to understand pointers and recursion is directly
correlated with the ability to be a great programmer.

Nothing about an all-Java CS degree really weeds out the students who lack the
mental agility to deal with these concepts. As an employer, I've seen that the
100% Java schools have started churning out quite a few CS graduates who are
simply not smart enough to work as programmers on anything more sophisticated
than Yet Another Java Accounting Application, although they did manage to squeak
through the newly-dumbed-down coursework. These students would never survive
6.001 at MIT, or CS 323 at Yale, and frankly, that is one reason why, as an
employer, a CS degree from MIT or Yale carries more weight than a CS degree from
Duke, which recently went All-Java, or U. Penn, which replaced Scheme and ML
with Java in trying to teach the class that nearly killed me and my friends,
CSE121. Not that I don't want to hire smart kids from Duke and Penn -- I do --
it's just a lot harder for me to figure out who they are. I used to be able to
tell the smart kids because they could rip through a recursive algorithm in
seconds, or implement linked-list manipulation functions using pointers as fast
as they could write on the whiteboard. But with a JavaSchool Grad, I can't tell
if they're struggling with these problems because they are undereducated or if
they're struggling with these problems because they don't actually have that
special part of the brain that they're going to need to do great programming
work. Paul Graham calls them Blub Programmers.

It's bad enough that JavaSchools fail to weed out the kids who are never going
to be great programmers, which the schools could justifiably say is not their
problem. Industry, or, at least, the recruiters-who-use-grep, are surely
clamoring for Java to be taught.

But JavaSchools also fail to train the brains of kids to be adept, agile, and
flexible enough to do good software design (and I don't mean OO "design", where
you spend countless hours rewriting your code to rejiggle your object hierarchy,
or you fret about faux "problems" like has-a vs. is-a). You need training to
think of things at multiple levels of abstraction simultaneously, and that kind
of thinking is exactly what you need to design great software architecture.

You may be wondering if teaching object oriented programming (OOP) is a good
weed-out substitute for pointers and recursion. The quick answer: no. Without
debating OOP on the merits, it is just not hard enough to weed out mediocre
programmers. OOP in school consists mostly of memorizing a bunch of vocabulary
terms like "encapsulation" and "inheritance" and taking multiple-choice
quizzicles on the difference between polymorphism and overloading. Not much
harder than memorizing famous dates and names in a history class, OOP poses
inadequate mental challenges to scare away first-year students. When you
struggle with an OOP problem, your program still works, it's just sort of hard
to maintain. Allegedly. But when you struggle with pointers, your program
produces the line Segmentation Fault and you have no idea what's going on, until
you stop and take a deep breath and really try to force your mind to work at two
different levels of abstraction simultaneously.

The recruiters-who-use-grep, by the way, are ridiculed here, and for good
reason. I have never met anyone who can do Scheme, Haskell, and C pointers who
can't pick up Java in two days, and create better Java code than people with
five years of experience in Java, but try explaining that to the average HR
drone.

But what about the CS mission of CS departments? They're not vocational schools!
It shouldn't be their job to train people to work in industry. That's for
community colleges and government retraining programs for displaced workers,
they will tell you. They're supposed to be giving students the fundamental tools
to live their lives, not preparing them for their first weeks on the job. Right?

Card Punch -- yes, I learned Fortran on one of these when I was 12.Still. CS is
proofs (recursion), algorithms (recursion), languages (lambda calculus),
operating systems (pointers), compilers (lambda calculus) -- and so the bottom
line is that a JavaSchool that won't teach C and won't teach Scheme is not
really teaching computer science, either. As useless as the concept of function
currying may be to the real world, it's obviously a prereq for CS grad school. I
can't understand why the professors on the curriculum committees at CS schools
have allowed their programs to be dumbed down to the point where not only can't
they produce working programmers, they can't even produce CS grad students who
might get PhDs and compete for their jobs. Oh wait. Never mind. Maybe I do
understand.

Actually if you go back and research the discussion that took place in academia
during the Great Java Shift, you'll notice that the biggest concern was whether
Java was simple enough to use as a teaching language.

My God, I thought, they're trying to dumb down the curriculum even further! Why
not spoon feed everything to the students? Let's have the TAs take their tests
for them, too, then nobody will switch to American Studies. How is anyone
supposed to learn anything if the curriculum has been carefully designed to make
everything easier than it already is? There seems to be a task force underway
(PDF) to figure out a simple subset of Java that can be taught to students,
producing simplified documentation that carefully hides all that EJB/J2EE crap
from their tender minds, so they don't have to worry their little heads with any
classes that you don't need to do the ever-easier CS problem sets.

The most sympathetic interpretation of why CS departments are so enthusiastic to
dumb down their classes is that it leaves them more time to teach actual CS
concepts, if they don't need to spend two whole lectures unconfusing students
about the difference between, say, a Java int and an Integer. Well, if that's
the case, 6.001 has the perfect answer for you: Scheme, a teaching language so
simple that the entire language can be taught to bright students in about ten
minutes; then you can spend the rest of the semester on fixed points.

Feh.

I'm going back to ones and zeros.

(You had ones? Lucky bastard! All we got were zeros.)
*** Bad Habits for C++ programmers 
说说我见到的一些不良现象吧。有些程序员干了十多年还这样。

1.不用namespace。导致全局空间被污染。或组织混乱带来维护障碍。或使用不便。

2.不使用接口隔离实现/头文件设计不当。文件间依赖过度紧密难于分离。或过于松散造成使用困难。以及包含次序耦合带来的编译问题。

3.不使用预编译头。
要么不用造成编译慢;要么“隐藏”了一些定义，使库外部无法使用。

4.拒绝使用c++11及高新的语言特性。
即使编译器支持也不用auto，不用lambda表达式，不用override。

5.对c/c++盲目推崇。
比如用性能问题贬低他们其实并不了解的C#和Java;比如认为所有有GC的语言都是解释执行的;直到被piapia打脸。

6.不会或不爱使用性能分析手段。
很多人你跟他谈结构不好，他开口闭口说为了性能。然后你一问具体数据就不吭声了。变成了:我觉得会更快。。。

7.滥用内嵌汇编。
迷信asm的效率和逼格。常常只是把简单问题复杂化，复杂问题天书化。

8.不写或滥用防御代码。
或不检查指针有效性。函数依赖传入参数决定是否崩溃。
或用assert代替，崩溃后连日志输出都没有。发布后出了问题就抓瞎。
或有检查，但失败后保持沉默，把问题隐患扩散到其他地方。

9.不用或滥用exception。
或完全不用导致某些逻辑复杂。
或混淆c++异常与操作系统异常。
或随意catch并忽视异常。
或没有对应防御机制造成内存泄露/漏过初始化等问题。

10.夸张的参数表。
不对参数封装或抽象为对象。使得接口难用/易出错/无谓的参数copy。

11.盲目使用c的不良遗产。
如随意的类型转换/类型擦除/函数参数默认值/函数变参/滥用union代替转换函数等等。代码建立在过多的隐喻上。

12.滥用const关键字。
过分强调实用const，近乎原教旨主义。绑架别人的接口无谓提升复杂度。

13.不了解/不愿用stl。
排序，搜索，数组，字符串都单写一套。问题多，效率差，还不方便使用。就是懒得看看stl手册。造一些无聊的轮子。

14.滥用继承机制。
从不组合。一说扩展功能就想到继承，甚至多重继承。把类型写得庞大臃肿。最后发现很难不动接口做任何改动。然后完蛋。

15.不封装数据成员;滥用静态/全局成员。
代码中飞线如乱麻。高度耦合。一有新需求就傻眼。

16.滥用虚函数。
鼓吹一切皆虚。直到某天在构造函数里调了一下。。。

17.从不画图。
业务逻辑混乱，代码层次模糊，对象生存期说不清楚。

18.滥用operator/滥用模板机制/滥用宏。
追求语法糖。把简单代码写到编辑器推导不出才满意。

19.不理解浮点值。
最常见的是把经过运算的float直接和定值比较。出现问题怪CPU不靠谱。

20.无视warning。
总认为认为能通过编译就大功告成了。然后埋一个如分枝无返回值之类的雷到运行时。

21.分不清平台API与C/C++标准库函数。
比如用MFC在win下写服务器。然后发现在Linux上无法部署。

22.不写或不会写测试。
从不用代码测试代码，拿测试人员或用户当小白鼠。
或把一段简陋的临时代码插到程序某处运行。觉得能跑就删除了。

23.过度具象的盲目追求“性能”。
设计时言必提性能。
茴字100种写法全都为性能。
高估函数调用开销。
高估new/delete的开销。
使用dowhile处理分枝。
把代码搞得像狗屎。

24.只用一种技术/语言/平台。
一切没听过的东西都不存在。

25.常见问题不想了解。
比如不理解字符编码与传输格式的区别;不知道各种调用约定的区别。这种太多了。其实就是花几分钟看看书的事。

26.自己的代码是金口玉言。
代码从不重构。也不许别人动。

27.注释与代码对不上，命名与作用都不上，变量名与类型对不上。
看到如“军衔”(rank)与“角色等级”(playerLevel)两个变量相比较就想抽人。

28.神奇的变量前缀。
当你看到m_lprpglpmcCur时，会想到这事啥？会理解成当前的RPGLocalPlayerMotionController吗？这缩写完全是把人搞昏。
另外即使没有IDE提示，我也认为这东西一点用都没有。缩小变量作用范围才是更好的选择。

作者：大狐狸
链接：https://www.zhihu.com/question/26134373/answer/91025385
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*** Foreword of SICP by Alan Perlis 
教育者、将领、饮食专家、心理学家，以及父母们，皆编程（规划）。士兵、学生和某些社
群，皆被编程（规划）。攻克大型问题，要使用一系列程序，其中大部分产生于求解问题的
途中。程序充斥着各种状况，于着手的问题，状况各异。编程作为一项智力活动，为了自个
儿能领会，你必须开始使用计算机去编程;你必须阅读、书写大量的计算机程序。程序是怎
样的，又是干什么的，这些都不大重要。重要的是，执行有多快，在构造更大规模的程序过
程中，配合其他程序有多流畅。 程序员必须努力寻求部分的完善性以及整体的融洽性。本
书中，”程序设计(program)”一词的使用将集中于程序的创建、执行和研究，这些程序用
Lisp写就，运行于数字式计算机。使用Lisp，不会限制我们的编程范围，这仅是程序的一种
描述记号罢了。

纵观本书主旨，我们将涉及三大关键点:人的思维方式，计算机程序集，以及计算机本身。
程序皆模型，它诞生于人的心智，是真实世界或精神世界的进程。此些进程，起于人的经验
和思考，数目巨大，细节复杂，无论何时，都仅能被部分理解。进程通过计算机程序进行模
拟，并不能一劳永逸。即便程序是精雕细琢的离散符号集，是交织嵌套的函数，它们依然需
要不断演化:当对模型的理解深化了，扩大了，推广了，我们就修改模型，直到取得相对稳
定的状态。接着，又得探寻另一个更好的模型。用计算机编程的欢欣之源，在于思维的不断
拓展，在于计算机装置的程序表示，在于其激发的理解力之飞升 。艺术诠释梦想，计算机
化用程序，实现梦想！

尽管计算机功能强大，它却是个苛刻的工头。它要求程序必须正确，我们的表述必须精细无
误。正如其他使用符号的场合，通过论证，我们也将相信程序的正确性。Lisp本身就能被赋
予一套语义(也就是另一个模型)，如果将程序的函数加以规范化，那么就能用逻辑学的证明
方法——谓词演算，来做经得起考验的论证。遗憾的是，一直以来，程序都在变大、变复杂，
规范本身的适用性、兼容性，以及正确性也变得值得怀疑。因此，正确性的完全形式化论证
很少出现在大型程序中。由于大型程序源于小程序，那么，建立正确性业已确定的、标准化
的程序结构的仓库就显得尤其重要了。我们称其为惯用语。接着学习将其组合成更大型的结
构，而这就要利用到有价值的组织技术。这些技术都充分展现在本书中，理解它们，对于投
入编程这项创造性事业来说，是不可或缺的。最为重要的是，发现并掌握强有力的组织技术，
以增进我们创建大型、重要之程序的能力。反过来说，正是因写大型程序太过费力，才刺激
我们去发明新方法，来减少大型程序中的大量函数和细节。

与程序不同，计算机必须遵守物理定律。如果计算机想快速执行——几个纳秒一次状态转换，
那么传输的电子就必须限制在小距离内(最多1.5英尺)。热量因大量元器件而产生并汇聚，
这必须消除。精湛的工程技艺的开发，平衡了功能多样性与器件密集性间的矛盾。不论何种
情况，硬件都比我们所关注的软件工作在更底层。将Lisp程序转换为“机器”程序的过程，本
身就是用程序所设计的抽象模型。对此过程的研究和创建，为设计其他模型的相关组织技术
提供了大量真知灼见。当然，计算机本身亦能被如此建模。试想:最小的物理开关元件用量
子力学建模，量子力学可用微分方程组来描述，微分方程的的细节特性能用数值逼近获得，
数值逼近能用计算机上执行的程序来表示，计算机程序由……组成 ，……！

区分上述三大关键点，不仅是为了方法上的便捷。虽然有人说它们皆存于自然人之头脑，但
逻辑上的划分导致三者间符号流动的加速。这使得它们的丰富性、鲜活性，以及无限可能性
远胜于其在人类实践中的自然演化（Even though, as they say, it's all in the head,
this logical separation induces an acceleration of symbolic traffic between
these foci whose richness, vitality, and potential is exceeded in human
experience only by the evolution of life itself.）。在最好情况下，三者间的关系是
相对稳定的。计算机内存永远不够大，计算速度永远不够快。每一次硬件技术的突破都产生
更大规模的程序设计产业，产生新的组织技术，产生更丰富的抽象模型。每个读者都应定期
反问自己，“到哪儿才是头，到哪才是头？”——但不要问得太频繁，不然这会让你泥淖在悲喜
交加之中，从而丧失编程的乐趣。

我们所写的程序中，有些(但不够多)具有精确的数学的功能。比如:数列排序，找出数列中
的的最大值，素数检验，或者计算平方根。我们称如上述的程序为算法，其中大量的因其具
有最优性能而被大家所熟知，这里要特别提及两个重要性能参数，程序的执行时间和数据存
储要求。程序员应该追求良好的算法和惯用法。虽然有些程序难以精确描述，但程序员有责
任去估计并不断地设法改进程序的性能。

Lisp是个幸存者，已被使用了约四分之一世纪。在用的语言中，只有Fortran比它久远。这
两语言都支持某些重要的应用领域的程序设计需要。Fortran用于科学和工程计算，Lisp用
于人工智能。这两领域将一如既往地重要，其中程序员是如此倾心于Lisp和Fortran，以致
它们可能继续被活跃使用至少四分之一世纪。

Lisp一直在改变着。本书使用的方言Scheme就是演化自最初的Lisp，并与后者在若干重要方
面有所不同，包括变量约束的静态作用域，以及允许函数生成函数作为函数值。在语义结构
方面，与早期Lisp族相比，Scheme更加接近于Algol 60。Algol 60再也不能重新流行了，只
能存活在Scheme和Pascal的基因里。 比起萦绕其周围的其他语言，很难找到像这样两种语
言去更好地沟通两个差异如此之巨大的文化。（It would be difficult to find two
languages that are the communicating coin of two more different cultures than
those gathered around these two languages.）Pascal是用来建造金字塔的——由大群人推
笨重的大石到指定地点，壮丽辉煌、令人震撼、静态的结构。Lisp是用来建造有机体的——由
小分队把无数更简单的处于变化之中的有机体安置在指定位置，壮丽辉煌、令人震撼、动态
的结构。组织原理在两语言中是相同的，除了极其重要的一点不同外:把自由输出功能托付
给Lisp程序员个体。这在Pascal程序员那里也能找到，却降低了不止一个数量级。Lisp程序
大大充实了函数库，这些函数的实用性超过了催生它们的应用。表，Lisp的固有数据结构，
为函数实用性的提升贡献巨大。表的简单结构和天然的适用性反映在函数，就是函数那令人
惊讶的普适性。而在Pascal，数据结构的过度声明导致函数的专用性，这阻碍并恶化了函数
间的临时配合。拥有100个函数，工作在1个数据结构之上，好过拥有10个函数，工作在10种
数据结构之上。结果，金字塔必定是矗立千年而不变，有机体要么演化，要么死亡。

为了看清上述差异，请试着比较Pascal入门书与本书对材料和练习的处理方法。不要困于假
象，说，这是本仅适用于MIT的教科书，它的独特性只不过是因为它出自MIT.准确地说，任
何一本Lisp编程书籍都应该如本书，无论其学生是谁，书本在何处使用。

注意，本书是关于程序设计的，异于大多数Lisp书籍，因那些书是为人工智能准备的。总之，
随着被研究的系统的不断扩大，程序设计的关键问题，在软件工程和人工智能之间将趋于统
一。这就解释了为何在人工智能领域之外，对Lisp的兴趣也正不断地在提高。

从人工智能的目标出发，可以预见，其研究将产生大量有意义的程序设计问题。在其他程序
设计文化里，这一连串的问题将引生新的语言。诚然，在任何极大型的程序设计工作中，一
个有效的组织原理就是控制并隔离任务(作业)模块间的信息流动，而这要通过新语言的发明
方可实现。当人们接近到与之最常交互的系统的边界时，这些语言趋于变得高级。结果，这
些系统就包含了大量重复的复杂的语言处理功能。Lisp拥有简洁的语法和语义，这使得语法
分析被看作是一项基本任务。这使得语法分析技术在Lisp程序里几乎没有地位，同时使得语
言处理器的构造对大型Lisp系统的发展变更速度而言，鲜有阻碍。最后，正是语法和语义的
极端简洁性，导致了Lisp程序员的自由以及负担。任何规模的Lisp程序，除了寥寥数行的之
外，无不充盈着各类函数。发明函数，组装函数;得到函数，再利用之发明函数（Invent
and fit; have fits and reinvent!）！让我们举杯庆贺那些将思想写进层层括号之巢的
Lisp程序员吧。

Alan J. Perlis

纽黑文市,康涅狄格

作者：拉曼卡
链接：https://www.zhihu.com/question/20246883/answer/45506752
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
** 3.18 efficient c++ notes
*** efficient c++ notes
**** 1
什么 RAII、异常已经有人说了，我再补充一些。。。（顺便反对某些回答不懂装懂，什么面向对象啊到底写没写过 C++ = =）
1. 在写一个 raw loop 之前，一定要考虑：我要写的东西 <algorithm> 能不能搞定？一定要善于利用 <algorithm>，一定！（而且利用 <algorithm> 可以秒杀各种笔试、面试题，部分可参考陈硕大大的文章）而且要意识到 iterator 与 algorithm 组合的强大威力，例如倒序打印字符串：
copy(crbegin(str), crend(str), std::ostream_iterator<char>{std::cout});
2. 在可能的情况下，要尽量使用非成员版函数（当年 STL 之父本来就是要把 begin() end() 这些做成非成员函数的，就是怕和标准委员会打起来才做成了成员函数。当然，现在开始陆陆续续擦屁股了。。。）例如 
using std::begin;
using std::end;
sort(begin(vec), end(vec));
当然，对于 std::list/forward_list 这种特殊的数据结构可能需要使用成员函数（例如 sort、reverse）以效率最大化。
3. 意识到 C++ 的“多态”远远不止所谓的虚函数（Tutorial - 1.60.0【伪处贴】关于C++14后boost::variant变得异常好用の件）

作者：刘雨培
链接：https://www.zhihu.com/question/41424757/answer/91037477
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
**** 2 
不光是不能学成“C风格的C++”，更重要的是不能学成“Java风格的C++”，前者还可以抢救一下，后者就只能放弃治疗了……
0、不要用裸指针，实在忍不住就用“世界上最傻的smart pointer”
1、不要用malloc/free，也不要用new/delete，用smart pointer管理对象的所有权和生存期
2、不要用函数指针，也不要用pure interface
3、不要用原生数组，用STL里的容器

作者：徐辰
链接：https://www.zhihu.com/question/41424757/answer/91048974
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
** 3.18 需要更多的“好的表达”
*** 需要更多的“好的表达”
今晚灯下仔细反思今年的关键词里有什么没做的好的，对于“好的习惯，好的思考”都还满意，而“好的表达，好的交流”实践的太少。那我今后就要努力地贯彻这两点。
*** TODO Aim to study ESL & Data Mining notes & HWs from 3.21 to end of April
This is an important step toward future interview. Should start early!
*** TODO 翻译project 
*** 简单明快
** 3.19 "乐"的境界
*** "乐"的境界
1. 学而时习之，不亦乐乎
2. 知之者不如好之者，好之者不如乐之者
*** 编程语言的"语感"(坑)
*** "志，气，力"的三位一体与"if.... then ...."的思考范式
*** It is better to learn C++(and any complicated thing) by concrete examples/projects
If you want to finish reading all the rules first then start writing code, it is going to be late and unnecessary.
** 3.22 忠实的、快乐的自我表达
*** 忠实的、快乐的自我表达
今天上完班早早的回到家就拿起了篮球一个人在小区球场练球。练着练着，就发现手感这些
的找回和单纯快乐地打球的关系太大了，不是说不该有争胜心，而是哪怕的争胜的时候也应
该去享受打球那种纯粹的快乐。推而广之，在做任何事情之前，或许都可以问问自己，这件
事自己能快乐开心地去做吗？如果可以，怎么去从中发掘最大的快乐和有趣？

编程和算法有趣且让我快乐，所以我一定会在这条路上走下去，不断提升自己。数学的很多
分支和问题对我来说也是如此。统计呢？统计的不少东西让目前的我觉得tedius（比如在公
司读的不少paper），但概率论在博弈等方面的应用我有兴趣，再比如在公司接触的因果推
断我也觉得蛮有意思的。

至于机器学习，统计学习，不得不说我虽然觉得很有用，但我在这方面积累的让我“开眼界”
或者说“震撼我”的例子太少了。说到底还是太浅尝辄止了。前两天下了决心这两月好好整一
整这块的内容，就要从实际的例子出发，相信通过努力一定能见识到让我“开眼界”的东西！
** 3.25 Principle of Inclusion & Exclusion(really powerful)

*** PIE
**** Probability form
**** Waring formula
**** He Min's master qualifying problems
*** Kenneth Lange's *Applied Probability* book is dense and fun
I plan to buy the book from the following link:
http://www.barnesandnoble.com/p/applied-probability-kenneth-lange/1119397767/2672928983758
** 3.31 代码的反编译
*** 代码的反编译
要理解这个问题，先要看「正」编译的过程是怎样的。
你有一个想法，这是一种人类自然语言可以表达出来的东西。你利用编程技能，把它「翻译」成你熟悉的一种编程语言:

然后编译器（compiler）将它翻译成机器所能理解的语言:

这中间的每一步都是一个「信息丢失」的过程。比如你说，我要把这些数排个序。然后你轻车熟路地写了个冒泡排序。你的原始动机其实已经一定程度上从你的代码里丢失了——有经验的人可能可以一眼看出你这段代码是在排序，而新手小明看到的只有一些for和if之类的东西。如果是更复杂的功能，那么可能过一段时间你自己都看不懂自己当时是想干什么。从程序语言到机器语言的过程其实也是一样的。这两个过程其实都是把「做什么」转换成「怎么做」的过程，转换完成之后，究竟一开始是要做什么，这个信息已经丢失了。

所谓「反编译」，其实就是找回这些丢失的信息的过程。从这个角度上来说，你阅读一段代码的过程，其实就是在将它「反编译」成自然语言。如果要完美地反编译，那只存在一种可能，就是信息完全没有丢失——比如说你阅读的这段代码有充分的注释，或者它使用了一种你所知晓的模式（这也是为什么大家一再强调注释和设计模式的重要性）。对于从机器语言到程序语言的反编译过程，也是一样。


作者：hillin
链接：https://www.zhihu.com/question/21853681/answer/74134768
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*** 如何在VS中正确输出中文，或者说使其支持Unicode?
**** code example(check the storage allocation in bytes for most primitive types)
//// to see the storage allocation in bytes for most primitive types
//#include<iostream>  
//#include<string>  
//#include <limits>  
//using namespace std;
//
//int main()
//{
//	cout << "type: \t\t" << "************size**************" << endl;
//	cout << "bool: \t\t" << "所占字节数：" << sizeof(bool);
//	cout << "\t最大值：" << (numeric_limits<bool>::max)();
//	cout << "\t\t最小值：" << (numeric_limits<bool>::min)() << endl;
//	cout << "char: \t\t" << "所占字节数：" << sizeof(char);
//	cout << "\t最大值：" << (numeric_limits<char>::max)();
//	cout << "\t\t最小值：" << (numeric_limits<char>::min)() << endl;
//	cout << "signed char: \t" << "所占字节数：" << sizeof(signed char);
//	cout << "\t最大值：" << (numeric_limits<signed char>::max)();
//	cout << "\t\t最小值：" << (numeric_limits<signed char>::min)() << endl;
//	cout << "unsigned char: \t" << "所占字节数：" << sizeof(unsigned char);
//	cout << "\t最大值：" << (numeric_limits<unsigned char>::max)();
//	cout << "\t\t最小值：" << (numeric_limits<unsigned char>::min)() << endl;
//	cout << "wchar_t: \t" << "所占字节数：" << sizeof(wchar_t);
//	cout << "\t最大值：" << (numeric_limits<wchar_t>::max)();
//	cout << "\t\t最小值：" << (numeric_limits<wchar_t>::min)() << endl;
//	cout << "short: \t\t" << "所占字节数：" << sizeof(short);
//	cout << "\t最大值：" << (numeric_limits<short>::max)();
//	cout << "\t\t最小值：" << (numeric_limits<short>::min)() << endl;
//	cout << "int: \t\t" << "所占字节数：" << sizeof(int);
//	cout << "\t最大值：" << (numeric_limits<int>::max)();
//	cout << "\t最小值：" << (numeric_limits<int>::min)() << endl;
//	cout << "unsigned: \t" << "所占字节数：" << sizeof(unsigned);
//	cout << "\t最大值：" << (numeric_limits<unsigned>::max)();
//	cout << "\t最小值：" << (numeric_limits<unsigned>::min)() << endl;
//	cout << "long: \t\t" << "所占字节数：" << sizeof(long);
//	cout << "\t最大值：" << (numeric_limits<long>::max)();
//	cout << "\t最小值：" << (numeric_limits<long>::min)() << endl;
//	cout << "unsigned long: \t" << "所占字节数：" << sizeof(unsigned long);
//	cout << "\t最大值：" << (numeric_limits<unsigned long>::max)();
//	cout << "\t最小值：" << (numeric_limits<unsigned long>::min)() << endl;
//	cout << "double: \t" << "所占字节数：" << sizeof(double);
//	cout << "\t最大值：" << (numeric_limits<double>::max)();
//	cout << "\t最小值：" << (numeric_limits<double>::min)() << endl;
//	cout << "long double: \t" << "所占字节数：" << sizeof(long double);
//	cout << "\t最大值：" << (numeric_limits<long double>::max)();
//	cout << "\t最小值：" << (numeric_limits<long double>::min)() << endl;
//	cout << "float: \t\t" << "所占字节数：" << sizeof(float);
//	cout << "\t最大值：" << (numeric_limits<float>::max)();
//	cout << "\t最小值：" << (numeric_limits<float>::min)() << endl;
//	cout << "size_t: \t" << "所占字节数：" << sizeof(size_t);
//	cout << "\t最大值：" << (numeric_limits<size_t>::max)();
//	cout << "\t最小值：" << (numeric_limits<size_t>::min)() << endl;
//	cout << "string: \t" << "所占字节数：" << sizeof(string) << endl;
//	// << "\t最大值：" << (numeric_limits<string>::max)() << "\t最小值：" << (numeric_limits<string>::min)() << endl;  
//	cout << "type: \t\t" << "************size**************" << endl;
//	return 0;
//}
**** comparison & comments 
以上code，在VS 2015下编译打印出来的中文皆乱码，而在spacemacs下编译打印则完全正确显示。
* April
** 4.1 Use Mathematica to produce function plots
*** Mathematica plotting eg
Plot[{Exp[x], x^2}, {x, 0, 4}]
*** Plan to get more familiar with Latex math writing by recording down notes via Latex
** 4.3 Tax Return filed
*** Tax Return information
**** state tax
Confirmation Number: 1707036
** 4.4 肚子胀,需要开始坚持跑步还有更规律地饮食
*** 肚子胀,需要开始坚持跑步还有更规律地饮食
原因未知，不知道和四五天前吃了二十颗multivitamin有关。如果通过跑步健身也消不下去就得去看医生。
还有就是，减少坐的时间，一天即使不跑步也尽量不要久坐，散散步也好。

